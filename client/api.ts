/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    sheet: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    sheetName: string;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    row: number;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    column: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    columnLetter: string;
}
/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    period: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    name: string;
    /**
     * 
     * @type {Item}
     * @memberof Cell
     */
    item: Item;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    formula?: string;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    excelFormula?: string;
    /**
     * 
     * @type {Address}
     * @memberof Cell
     */
    address?: Address;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cell
     */
    dependentCellNames: Array<string>;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    stockAnalysisId: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Commentary
 */
export interface Commentary {
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    commentary?: string;
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    generatorClass?: string;
}
/**
 * 
 * @export
 * @interface Component
 */
export interface Component {
    /**
     * 
     * @type {number}
     * @memberof Component
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof Component
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface CompoundedGrowth
 */
export interface CompoundedGrowth {
    /**
     * 
     * @type {number}
     * @memberof CompoundedGrowth
     */
    growthRate: number;
}
/**
 * 
 * @export
 * @interface DerivedStockAnalytics
 */
export interface DerivedStockAnalytics {
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    zeroGrowthPrice?: number;
    /**
     * 
     * @type {{ [key: string]: Waterfall; }}
     * @memberof DerivedStockAnalytics
     */
    businessWaterfall: { [key: string]: Waterfall; };
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    shareOutstanding: Item;
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    profitPerShare: Item;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    targetPrice: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    finalPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    discountRate: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    revenueCAGR: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    currentPrice: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    irr?: number;
}
/**
 * 
 * @export
 * @interface EvaluateModelRequest
 */
export interface EvaluateModelRequest {
    /**
     * 
     * @type {Model}
     * @memberof EvaluateModelRequest
     */
    model: Model;
}
/**
 * 
 * @export
 * @interface EvaluateModelResponse
 */
export interface EvaluateModelResponse {
    /**
     * 
     * @type {Model}
     * @memberof EvaluateModelResponse
     */
    model: Model;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof EvaluateModelResponse
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof EvaluateModelResponse
     */
    derivedStockAnalytics: DerivedStockAnalytics;
}
/**
 * 
 * @export
 * @interface FindStockAnalysisResponse
 */
export interface FindStockAnalysisResponse {
    /**
     * 
     * @type {Array<StockAnalysisProjection>}
     * @memberof FindStockAnalysisResponse
     */
    stockAnalyses: Array<StockAnalysisProjection>;
}
/**
 * 
 * @export
 * @interface FixedCost
 */
export interface FixedCost {
    /**
     * 
     * @type {number}
     * @memberof FixedCost
     */
    cost: number;
}
/**
 * 
 * @export
 * @interface HistoricalValue
 */
export interface HistoricalValue {
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    factId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HistoricalValue
     */
    factIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    conceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentFiscalPeriodFocus?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    documentFiscalYearFocus?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentPeriodEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    instant?: string;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    type: ItemTypeEnum;
    /**
     * 
     * @type {HistoricalValue}
     * @memberof Item
     */
    historicalValue?: HistoricalValue;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    formula: string;
    /**
     * 
     * @type {SumOfOtherItems}
     * @memberof Item
     */
    sumOfOtherItems?: SumOfOtherItems;
    /**
     * 
     * @type {ProductOfOtherItems}
     * @memberof Item
     */
    productOfOtherItems?: ProductOfOtherItems;
    /**
     * 
     * @type {ManualProjections}
     * @memberof Item
     */
    manualProjections?: ManualProjections;
    /**
     * 
     * @type {PercentOfRevenue}
     * @memberof Item
     */
    percentOfRevenue?: PercentOfRevenue;
    /**
     * 
     * @type {PercentOfAnotherItem}
     * @memberof Item
     */
    percentOfAnotherItem?: PercentOfAnotherItem;
    /**
     * 
     * @type {CompoundedGrowth}
     * @memberof Item
     */
    compoundedGrowth?: CompoundedGrowth;
    /**
     * 
     * @type {FixedCost}
     * @memberof Item
     */
    fixedCost?: FixedCost;
    /**
     * 
     * @type {Commentary}
     * @memberof Item
     */
    commentaries?: Commentary;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemTypeEnum {
    CompoundedGrowth = 'CompoundedGrowth',
    SumOfOtherItems = 'SumOfOtherItems',
    ProductOfOtherItems = 'ProductOfOtherItems',
    Custom = 'Custom',
    Discrete = 'Discrete',
    ManualProjections = 'ManualProjections',
    PercentOfRevenue = 'PercentOfRevenue',
    PercentOfAnotherItem = 'PercentOfAnotherItem',
    FixedCost = 'FixedCost'
}

/**
 * 
 * @export
 * @interface ManualProjection
 */
export interface ManualProjection {
    /**
     * 
     * @type {number}
     * @memberof ManualProjection
     */
    fiscalYear: number;
    /**
     * 
     * @type {number}
     * @memberof ManualProjection
     */
    value: number;
}
/**
 * 
 * @export
 * @interface ManualProjections
 */
export interface ManualProjections {
    /**
     * 
     * @type {Array<ManualProjection>}
     * @memberof ManualProjections
     */
    manualProjections: Array<ManualProjection>;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    adsh?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    name?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    itemOverrides: Array<Item>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Model
     */
    suppressedItems: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    totalRevenueConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    epsConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    netIncomeConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    sharesOutstandingConceptName?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    incomeStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    balanceSheetItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    cashFlowStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    otherItems: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    beta: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    riskFreeRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    equityRiskPremium: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    terminalGrowthRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    periods: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelColumnOffset: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelRowOffset: number;
}
/**
 * 
 * @export
 * @interface PercentOfAnotherItem
 */
export interface PercentOfAnotherItem {
    /**
     * 
     * @type {string}
     * @memberof PercentOfAnotherItem
     */
    itemName: string;
    /**
     * 
     * @type {number}
     * @memberof PercentOfAnotherItem
     */
    percent: number;
}
/**
 * 
 * @export
 * @interface PercentOfRevenue
 */
export interface PercentOfRevenue {
    /**
     * 
     * @type {number}
     * @memberof PercentOfRevenue
     */
    percentOfRevenue: number;
}
/**
 * 
 * @export
 * @interface ProductComponent
 */
export interface ProductComponent {
    /**
     * 
     * @type {string}
     * @memberof ProductComponent
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface ProductOfOtherItems
 */
export interface ProductOfOtherItems {
    /**
     * 
     * @type {Array<ProductComponent>}
     * @memberof ProductOfOtherItems
     */
    components: Array<ProductComponent>;
}
/**
 * 
 * @export
 * @interface StockAnalysis2
 */
export interface StockAnalysis2 {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    ticker?: string;
    /**
     * 
     * @type {Model}
     * @memberof StockAnalysis2
     */
    model: Model;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof StockAnalysis2
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof StockAnalysis2
     */
    derivedStockAnalytics?: DerivedStockAnalytics;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    userId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysis2
     */
    tags: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysis2
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface StockAnalysisProjection
 */
export interface StockAnalysisProjection {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    ticker?: string;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    currentPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    targetPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    finalPrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysisProjection
     */
    published?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysisProjection
     */
    tags: Array<string>;
}
/**
 * 
 * @export
 * @interface SumOfOtherItems
 */
export interface SumOfOtherItems {
    /**
     * 
     * @type {Array<Component>}
     * @memberof SumOfOtherItems
     */
    components: Array<Component>;
}
/**
 * 
 * @export
 * @interface WatchList
 */
export interface WatchList {
    /**
     * 
     * @type {string}
     * @memberof WatchList
     */
    get_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WatchList
     */
    stockAnalysisIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WatchList
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface Waterfall
 */
export interface Waterfall {
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    revenue: Cell;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Waterfall
     */
    expenses: Array<Cell>;
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    profit: Cell;
}

/**
 * CommentsControllerApi - axios parameter creator
 * @export
 */
export const CommentsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('getComments', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/public/comments/{stockAnalysisId}`
                .replace(`{${"stockAnalysisId"}}`, encodeURIComponent(String(stockAnalysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment: async (comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('postComment', 'comment', comment)
            const localVarPath = `/public/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsControllerApi - functional programming interface
 * @export
 */
export const CommentsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postComment(comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postComment(comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentsControllerApi - factory interface
 * @export
 */
export const CommentsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(stockAnalysisId: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.getComments(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(comment: Comment, options?: any): AxiosPromise<void> {
            return localVarFp.postComment(comment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsControllerApi - object-oriented interface
 * @export
 * @class CommentsControllerApi
 * @extends {BaseAPI}
 */
export class CommentsControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsControllerApi
     */
    public getComments(stockAnalysisId: string, options?: any) {
        return CommentsControllerApiFp(this.configuration).getComments(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsControllerApi
     */
    public postComment(comment: Comment, options?: any) {
        return CommentsControllerApiFp(this.configuration).postComment(comment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublishedStockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const PublishedStockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses: async (userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublishedStockAnalysis', 'id', id)
            const localVarPath = `/public/published-stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        top4StockAnalyses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses/top4`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - functional programming interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublishedStockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async top4StockAnalyses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.top4StockAnalyses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - factory interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublishedStockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getPublishedStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        top4StockAnalyses(options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.top4StockAnalyses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublishedStockAnalysisControllerApi - object-oriented interface
 * @export
 * @class PublishedStockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class PublishedStockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public getPublishedStockAnalysis(id: string, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).getPublishedStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public top4StockAnalyses(options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).top4StockAnalyses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis: async (evaluateModelRequest: EvaluateModelRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluateModelRequest' is not null or undefined
            assertParamExists('evaluateStockAnalysis', 'evaluateModelRequest', evaluateModelRequest)
            const localVarPath = `/api/stock-analyzer/stock-analyses/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluateModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses: async (published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @summary Refresh a stock analysis by rerunning the model
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStockAnalysis: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('refreshStockAnalysis', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/stock-analyzer/stock-analyses/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStockAnalysis: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('saveStockAnalysis', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/unpublish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluateModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateStockAnalysis(evaluateModelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @summary Refresh a stock analysis by rerunning the model
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshStockAnalysis(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveStockAnalysis(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisControllerApi - factory interface
 * @export
 */
export const StockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any): AxiosPromise<EvaluateModelResponse> {
            return localVarFp.evaluateStockAnalysis(evaluateModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.publish(id, options).then((request) => request(axios, basePath));
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @summary Refresh a stock analysis by rerunning the model
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.refreshStockAnalysis(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<void> {
            return localVarFp.saveStockAnalysis(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.unpublish(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public deleteStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).deleteStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
     * @param {EvaluateModelRequest} evaluateModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).evaluateStockAnalysis(evaluateModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [published] 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public getStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).getStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public publish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).publish(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
     * @summary Refresh a stock analysis by rerunning the model
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).refreshStockAnalysis(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).saveStockAnalysis(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public unpublish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).unpublish(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisCronJobsControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisCronJobsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analysis-cron-jobs/update-prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisCronJobsControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisCronJobsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisCronJobsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisCronJobsControllerApi - factory interface
 * @export
 */
export const StockAnalysisCronJobsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisCronJobsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrices(options?: any): AxiosPromise<void> {
            return localVarFp.updatePrices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisCronJobsControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisCronJobsControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisCronJobsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisCronJobsControllerApi
     */
    public updatePrices(options?: any) {
        return StockAnalysisCronJobsControllerApiFp(this.configuration).updatePrices(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WatchListsControllerApi - axios parameter creator
 * @export
 */
export const WatchListsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatch: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('unwatch', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watch: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('watch', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchListsControllerApi - functional programming interface
 * @export
 */
export const WatchListsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchListsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unwatch(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unwatch(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watch(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watch(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WatchListsControllerApi - factory interface
 * @export
 */
export const WatchListsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchListsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchList(options?: any): AxiosPromise<WatchList> {
            return localVarFp.getWatchList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatch(stockAnalysisId: string, options?: any): AxiosPromise<WatchList> {
            return localVarFp.unwatch(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watch(stockAnalysisId: string, options?: any): AxiosPromise<WatchList> {
            return localVarFp.watch(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchListsControllerApi - object-oriented interface
 * @export
 * @class WatchListsControllerApi
 * @extends {BaseAPI}
 */
export class WatchListsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public getWatchList(options?: any) {
        return WatchListsControllerApiFp(this.configuration).getWatchList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public unwatch(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).unwatch(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public watch(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).watch(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }
}


