/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    sheet: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    sheetName: string;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    row: number;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    column: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    columnLetter: string;
}
/**
 * 
 * @export
 * @interface AggregatedFact
 */
export interface AggregatedFact {
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregatedFact
     */
    factIds: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof AggregatedFact
     */
    value: number;
    /**
     * 
     * @type {string}
     * @memberof AggregatedFact
     */
    conceptName: string;
    /**
     * 
     * @type {string}
     * @memberof AggregatedFact
     */
    documentFiscalPeriodFocus?: AggregatedFactDocumentFiscalPeriodFocusEnum;
    /**
     * 
     * @type {string}
     * @memberof AggregatedFact
     */
    documentPeriodEndDate: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AggregatedFactDocumentFiscalPeriodFocusEnum {
    Fy = 'FY',
    Q1 = 'Q1',
    Q2 = 'Q2',
    Q3 = 'Q3',
    Q4 = 'Q4',
    Na = 'NA'
}

/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    period: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    name: string;
    /**
     * 
     * @type {Item}
     * @memberof Cell
     */
    item: Item;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    formula?: string;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    excelFormula?: string;
    /**
     * 
     * @type {Address}
     * @memberof Cell
     */
    address?: Address;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cell
     */
    dependentCellNames: Array<string>;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    stockAnalysisId: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Commentary
 */
export interface Commentary {
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    commentary?: string;
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    generatorClass?: string;
}
/**
 * 
 * @export
 * @interface Component
 */
export interface Component {
    /**
     * 
     * @type {number}
     * @memberof Component
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof Component
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface CompoundedGrowth
 */
export interface CompoundedGrowth {
    /**
     * 
     * @type {number}
     * @memberof CompoundedGrowth
     */
    growthRate: number;
}
/**
 * 
 * @export
 * @interface DerivedStockAnalytics
 */
export interface DerivedStockAnalytics {
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    zeroGrowthPrice: number;
    /**
     * 
     * @type {{ [key: string]: Waterfall; }}
     * @memberof DerivedStockAnalytics
     */
    businessWaterfall: { [key: string]: Waterfall; };
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    shareOutstanding: Item;
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    profitPerShare: Item;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    targetPrice: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    discountRate: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    revenueCAGR: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    currentPrice: number;
}
/**
 * 
 * @export
 * @interface Discrete
 */
export interface Discrete {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Discrete
     */
    formulas: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface EarlyAccessRequest
 */
export interface EarlyAccessRequest {
    /**
     * 
     * @type {string}
     * @memberof EarlyAccessRequest
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof EarlyAccessRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof EarlyAccessRequest
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface EdgarEntity
 */
export interface EdgarEntity {
    /**
     * 
     * @type {string}
     * @memberof EdgarEntity
     */
    get_id?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntity
     */
    get_index?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntity
     */
    get_type?: string;
    /**
     * 
     * @type {EdgarEntitySource}
     * @memberof EdgarEntity
     */
    get_source: EdgarEntitySource;
}
/**
 * 
 * @export
 * @interface EdgarEntitySource
 */
export interface EdgarEntitySource {
    /**
     * 
     * @type {string}
     * @memberof EdgarEntitySource
     */
    entity: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntitySource
     */
    entity_words: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntitySource
     */
    tickers?: string;
    /**
     * 
     * @type {number}
     * @memberof EdgarEntitySource
     */
    rank?: number;
}
/**
 * 
 * @export
 * @interface EdgarFilingMetadata
 */
export interface EdgarFilingMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    ciks: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    period_ending: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    root_form?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    file_num: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    display_names: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    sequence?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    biz_states: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    sics: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    form: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    adsh: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    biz_locations: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    file_date: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    file_type?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    file_description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    inc_states: Array<string>;
}
/**
 * 
 * @export
 * @interface EvaluateModelRequest
 */
export interface EvaluateModelRequest {
    /**
     * 
     * @type {Model}
     * @memberof EvaluateModelRequest
     */
    model: Model;
}
/**
 * 
 * @export
 * @interface EvaluateModelResponse
 */
export interface EvaluateModelResponse {
    /**
     * 
     * @type {Array<Cell>}
     * @memberof EvaluateModelResponse
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof EvaluateModelResponse
     */
    derivedStockAnalytics: DerivedStockAnalytics;
}
/**
 * 
 * @export
 * @interface Fact
 */
export interface Fact {
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    instanceDocumentElementId: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    instanceDocumentElementName: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    cik: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    adsh: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    entityName: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    primarySymbol: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    formType: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    conceptName: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    conceptHref: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    namespace: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    instant?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    documentFiscalPeriodFocus: FactDocumentFiscalPeriodFocusEnum;
    /**
     * 
     * @type {number}
     * @memberof Fact
     */
    documentFiscalYearFocus: number;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    documentPeriodEndDate: string;
    /**
     * 
     * @type {Array<XbrlExplicitMember>}
     * @memberof Fact
     */
    explicitMembers: Array<XbrlExplicitMember>;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    sourceDocument: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    verboseLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    labelTerse?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    documentation?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    stringValue: string;
    /**
     * 
     * @type {number}
     * @memberof Fact
     */
    doubleValue?: number;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    lastUpdated: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FactDocumentFiscalPeriodFocusEnum {
    Fy = 'FY',
    Q1 = 'Q1',
    Q2 = 'Q2',
    Q3 = 'Q3',
    Q4 = 'Q4',
    Na = 'NA'
}

/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    get_id: string;
    /**
     * 
     * @type {object}
     * @memberof Feedback
     */
    body: object;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    version: string;
}
/**
 * 
 * @export
 * @interface FilingEntity
 */
export interface FilingEntity {
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    cik: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    tradingSymbol?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    entityType?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    sic?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    sicDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof FilingEntity
     */
    insiderTransactionForOwnerExists?: number;
    /**
     * 
     * @type {number}
     * @memberof FilingEntity
     */
    insiderTransactionForIssuerExists?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilingEntity
     */
    tickers: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilingEntity
     */
    exchanges: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    ein?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    investorWebsite?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    fiscalYearEnd?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    stateOfIncorporation?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    stateOfIncorporationDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    phone?: string;
    /**
     * 
     * @type {Address}
     * @memberof FilingEntity
     */
    businessAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    statusMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    latestAdsh?: string;
    /**
     * 
     * @type {ModelTemplate}
     * @memberof FilingEntity
     */
    modelTemplate?: ModelTemplate;
}
/**
 * 
 * @export
 * @interface FindStockAnalysisResponse
 */
export interface FindStockAnalysisResponse {
    /**
     * 
     * @type {number}
     * @memberof FindStockAnalysisResponse
     */
    totalCount: number;
    /**
     * 
     * @type {Array<StockAnalysis2>}
     * @memberof FindStockAnalysisResponse
     */
    stockAnalyses: Array<StockAnalysis2>;
}
/**
 * 
 * @export
 * @interface FixedCost
 */
export interface FixedCost {
    /**
     * 
     * @type {number}
     * @memberof FixedCost
     */
    cost: number;
}
/**
 * 
 * @export
 * @interface FixedCostAutoFill
 */
export interface FixedCostAutoFill {
    /**
     * 
     * @type {string}
     * @memberof FixedCostAutoFill
     */
    label: string;
    /**
     * 
     * @type {FixedCost}
     * @memberof FixedCostAutoFill
     */
    fixedCost: FixedCost;
}
/**
 * 
 * @export
 * @interface HistoricalValue
 */
export interface HistoricalValue {
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    factId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HistoricalValue
     */
    factIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    conceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentFiscalPeriodFocus?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    documentFiscalYearFocus?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentPeriodEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    instant?: string;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    type: ItemTypeEnum;
    /**
     * 
     * @type {HistoricalValue}
     * @memberof Item
     */
    historicalValue?: HistoricalValue;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    formula: string;
    /**
     * 
     * @type {SumOfOtherItems}
     * @memberof Item
     */
    sumOfOtherItems?: SumOfOtherItems;
    /**
     * 
     * @type {SubscriptionRevenue}
     * @memberof Item
     */
    subscriptionRevenue?: SubscriptionRevenue;
    /**
     * 
     * @type {UnitSalesRevenue}
     * @memberof Item
     */
    unitSalesRevenue?: UnitSalesRevenue;
    /**
     * 
     * @type {Discrete}
     * @memberof Item
     */
    discrete?: Discrete;
    /**
     * 
     * @type {PercentOfTotalAsset}
     * @memberof Item
     */
    percentOfTotalAsset?: PercentOfTotalAsset;
    /**
     * 
     * @type {PercentOfRevenue}
     * @memberof Item
     */
    percentOfRevenue?: PercentOfRevenue;
    /**
     * 
     * @type {CompoundedGrowth}
     * @memberof Item
     */
    compoundedGrowth?: CompoundedGrowth;
    /**
     * 
     * @type {FixedCost}
     * @memberof Item
     */
    fixedCost?: FixedCost;
    /**
     * 
     * @type {boolean}
     * @memberof Item
     */
    stockBasedCompensation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Item
     */
    nonCashExpense?: boolean;
    /**
     * 
     * @type {Commentary}
     * @memberof Item
     */
    commentaries?: Commentary;
    /**
     * 
     * @type {boolean}
     * @memberof Item
     */
    subtotal: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemTypeEnum {
    Discrete = 'Discrete',
    SubscriptionRevenue = 'SubscriptionRevenue',
    CompoundedGrowth = 'CompoundedGrowth',
    SumOfOtherItems = 'SumOfOtherItems',
    UnitSalesRevenue = 'UnitSalesRevenue',
    Custom = 'Custom',
    PercentOfRevenue = 'PercentOfRevenue',
    PercentOfTotalAsset = 'PercentOfTotalAsset',
    FixedCost = 'FixedCost'
}

/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    adsh?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    itemOverrides: Array<Item>;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    totalRevenueConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    epsConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    netIncomeConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    sharesOutstandingConceptName?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    incomeStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    balanceSheetItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    cashFlowStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    otherItems: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    beta: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    riskFreeRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    equityRiskPremium: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    terminalGrowthRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    periods: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelColumnOffset: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelRowOffset: number;
}
/**
 * 
 * @export
 * @interface ModelTemplate
 */
export interface ModelTemplate {
    /**
     * 
     * @type {string}
     * @memberof ModelTemplate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTemplate
     */
    template: string;
}
/**
 * 
 * @export
 * @interface MxParserEvaluateRequest
 */
export interface MxParserEvaluateRequest {
    /**
     * 
     * @type {string}
     * @memberof MxParserEvaluateRequest
     */
    formula: string;
}
/**
 * 
 * @export
 * @interface MxParserEvaluateResponse
 */
export interface MxParserEvaluateResponse {
    /**
     * 
     * @type {number}
     * @memberof MxParserEvaluateResponse
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof MxParserEvaluateResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface PercentOfRevenue
 */
export interface PercentOfRevenue {
    /**
     * 
     * @type {number}
     * @memberof PercentOfRevenue
     */
    percentOfRevenue: number;
}
/**
 * 
 * @export
 * @interface PercentOfRevenueAutoFill
 */
export interface PercentOfRevenueAutoFill {
    /**
     * 
     * @type {string}
     * @memberof PercentOfRevenueAutoFill
     */
    label: string;
    /**
     * 
     * @type {PercentOfRevenue}
     * @memberof PercentOfRevenueAutoFill
     */
    percentOfRevenue: PercentOfRevenue;
}
/**
 * 
 * @export
 * @interface PercentOfTotalAsset
 */
export interface PercentOfTotalAsset {
    /**
     * 
     * @type {number}
     * @memberof PercentOfTotalAsset
     */
    percentOfTotalAsset: number;
}
/**
 * 
 * @export
 * @interface StockAnalysis2
 */
export interface StockAnalysis2 {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    ticker?: string;
    /**
     * 
     * @type {Model}
     * @memberof StockAnalysis2
     */
    model: Model;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof StockAnalysis2
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof StockAnalysis2
     */
    derivedStockAnalytics?: DerivedStockAnalytics;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    userId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysis2
     */
    tags: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysis2
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface StockAnalysisInterest
 */
export interface StockAnalysisInterest {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisInterest
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisInterest
     */
    email: string;
    /**
     * 
     * @type {Array<StockAnalysisRequest>}
     * @memberof StockAnalysisInterest
     */
    requests: Array<StockAnalysisRequest>;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisInterest
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface StockAnalysisRequest
 */
export interface StockAnalysisRequest {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    cik: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    ticker: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface SubscriptionRevenue
 */
export interface SubscriptionRevenue {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionRevenue
     */
    totalSubscriptionAtTerminalYear: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionRevenue
     */
    initialSubscriptions: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionRevenue
     */
    averageRevenuePerSubscription: number;
}
/**
 * 
 * @export
 * @interface SumOfOtherItems
 */
export interface SumOfOtherItems {
    /**
     * 
     * @type {Array<Component>}
     * @memberof SumOfOtherItems
     */
    components: Array<Component>;
}
/**
 * 
 * @export
 * @interface UnitSalesRevenue
 */
export interface UnitSalesRevenue {
    /**
     * 
     * @type {number}
     * @memberof UnitSalesRevenue
     */
    steadyStateUnitsSold: number;
    /**
     * 
     * @type {number}
     * @memberof UnitSalesRevenue
     */
    averageSellingPrice: number;
    /**
     * 
     * @type {number}
     * @memberof UnitSalesRevenue
     */
    initialUnitsSold: number;
}
/**
 * 
 * @export
 * @interface Waterfall
 */
export interface Waterfall {
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    revenue: Cell;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Waterfall
     */
    expenses: Array<Cell>;
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    profit: Cell;
}
/**
 * 
 * @export
 * @interface XbrlExplicitMember
 */
export interface XbrlExplicitMember {
    /**
     * 
     * @type {string}
     * @memberof XbrlExplicitMember
     */
    dimension: string;
    /**
     * 
     * @type {string}
     * @memberof XbrlExplicitMember
     */
    value: string;
}

/**
 * CommentsControllerApi - axios parameter creator
 * @export
 */
export const CommentsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('getComments', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/public/comments/{stockAnalysisId}`
                .replace(`{${"stockAnalysisId"}}`, encodeURIComponent(String(stockAnalysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment: async (comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('postComment', 'comment', comment)
            const localVarPath = `/public/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsControllerApi - functional programming interface
 * @export
 */
export const CommentsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postComment(comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postComment(comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentsControllerApi - factory interface
 * @export
 */
export const CommentsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(stockAnalysisId: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.getComments(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(comment: Comment, options?: any): AxiosPromise<void> {
            return localVarFp.postComment(comment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsControllerApi - object-oriented interface
 * @export
 * @class CommentsControllerApi
 * @extends {BaseAPI}
 */
export class CommentsControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsControllerApi
     */
    public getComments(stockAnalysisId: string, options?: any) {
        return CommentsControllerApiFp(this.configuration).getComments(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsControllerApi
     */
    public postComment(comment: Comment, options?: any) {
        return CommentsControllerApiFp(this.configuration).postComment(comment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgarExplorerControllerApi - axios parameter creator
 * @export
 */
export const EdgarExplorerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities: async (term: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchEntities', 'term', term)
            const localVarPath = `/public/edgar-explorer/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFilings: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('searchFilings', 'cik', cik)
            const localVarPath = `/public/edgar-explorer/filings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgarExplorerControllerApi - functional programming interface
 * @export
 */
export const EdgarExplorerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgarExplorerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchEntities(term: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdgarEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchEntities(term, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFilings(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdgarFilingMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFilings(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgarExplorerControllerApi - factory interface
 * @export
 */
export const EdgarExplorerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgarExplorerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities(term: string, options?: any): AxiosPromise<Array<EdgarEntity>> {
            return localVarFp.searchEntities(term, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFilings(cik: string, options?: any): AxiosPromise<Array<EdgarFilingMetadata>> {
            return localVarFp.searchFilings(cik, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgarExplorerControllerApi - object-oriented interface
 * @export
 * @class EdgarExplorerControllerApi
 * @extends {BaseAPI}
 */
export class EdgarExplorerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} term 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgarExplorerControllerApi
     */
    public searchEntities(term: string, options?: any) {
        return EdgarExplorerControllerApiFp(this.configuration).searchEntities(term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgarExplorerControllerApi
     */
    public searchFilings(cik: string, options?: any) {
        return EdgarExplorerControllerApiFp(this.configuration).searchFilings(cik, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactAutoFillerControllerApi - axios parameter creator
 * @export
 */
export const FactAutoFillerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFixedCostAutoFills: async (factId: string, model: Model, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getFixedCostAutoFills', 'factId', factId)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('getFixedCostAutoFills', 'model', model)
            const localVarPath = `/api/fact-auto-filler/{factId}/fixed-cost`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentOfRevenueAutoFills: async (factId: string, model: Model, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getPercentOfRevenueAutoFills', 'factId', factId)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('getPercentOfRevenueAutoFills', 'model', model)
            const localVarPath = `/api/fact-auto-filler/{factId}/percent-of-revenue`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactAutoFillerControllerApi - functional programming interface
 * @export
 */
export const FactAutoFillerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactAutoFillerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFixedCostAutoFills(factId: string, model: Model, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FixedCostAutoFill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFixedCostAutoFills(factId, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPercentOfRevenueAutoFills(factId: string, model: Model, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PercentOfRevenueAutoFill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPercentOfRevenueAutoFills(factId, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactAutoFillerControllerApi - factory interface
 * @export
 */
export const FactAutoFillerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactAutoFillerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFixedCostAutoFills(factId: string, model: Model, options?: any): AxiosPromise<Array<FixedCostAutoFill>> {
            return localVarFp.getFixedCostAutoFills(factId, model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentOfRevenueAutoFills(factId: string, model: Model, options?: any): AxiosPromise<Array<PercentOfRevenueAutoFill>> {
            return localVarFp.getPercentOfRevenueAutoFills(factId, model, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactAutoFillerControllerApi - object-oriented interface
 * @export
 * @class FactAutoFillerControllerApi
 * @extends {BaseAPI}
 */
export class FactAutoFillerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} factId 
     * @param {Model} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactAutoFillerControllerApi
     */
    public getFixedCostAutoFills(factId: string, model: Model, options?: any) {
        return FactAutoFillerControllerApiFp(this.configuration).getFixedCostAutoFills(factId, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} factId 
     * @param {Model} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactAutoFillerControllerApi
     */
    public getPercentOfRevenueAutoFills(factId: string, model: Model, options?: any) {
        return FactAutoFillerControllerApiFp(this.configuration).getPercentOfRevenueAutoFills(factId, model, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactBaseControllerApi - axios parameter creator
 * @export
 */
export const FactBaseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestFiling: async (cik: string, adsh: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('ingestFiling', 'cik', cik)
            // verify required parameter 'adsh' is not null or undefined
            assertParamExists('ingestFiling', 'adsh', adsh)
            const localVarPath = `/api/fact-base/filing-ingestor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (adsh !== undefined) {
                localVarQueryParameter['adsh'] = adsh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cik 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestQ4Facts: async (cik: string, year: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('ingestQ4Facts', 'cik', cik)
            // verify required parameter 'year' is not null or undefined
            assertParamExists('ingestQ4Facts', 'year', year)
            const localVarPath = `/api/fact-base/filing-ingestor/q4`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [numYearsToLookback] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRssFilingIngestor: async (numYearsToLookback?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/fact-base/rss-filing-ingestor`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (numYearsToLookback !== undefined) {
                localVarQueryParameter['numYearsToLookback'] = numYearsToLookback;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactBaseControllerApi - functional programming interface
 * @export
 */
export const FactBaseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactBaseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestFiling(cik: string, adsh: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestFiling(cik, adsh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} cik 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ingestQ4Facts(cik: string, year: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ingestQ4Facts(cik, year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [numYearsToLookback] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runRssFilingIngestor(numYearsToLookback?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runRssFilingIngestor(numYearsToLookback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactBaseControllerApi - factory interface
 * @export
 */
export const FactBaseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactBaseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestFiling(cik: string, adsh: string, options?: any): AxiosPromise<void> {
            return localVarFp.ingestFiling(cik, adsh, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cik 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ingestQ4Facts(cik: string, year: number, options?: any): AxiosPromise<void> {
            return localVarFp.ingestQ4Facts(cik, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [numYearsToLookback] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runRssFilingIngestor(numYearsToLookback?: number, options?: any): AxiosPromise<void> {
            return localVarFp.runRssFilingIngestor(numYearsToLookback, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactBaseControllerApi - object-oriented interface
 * @export
 * @class FactBaseControllerApi
 * @extends {BaseAPI}
 */
export class FactBaseControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {string} adsh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseControllerApi
     */
    public ingestFiling(cik: string, adsh: string, options?: any) {
        return FactBaseControllerApiFp(this.configuration).ingestFiling(cik, adsh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cik 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseControllerApi
     */
    public ingestQ4Facts(cik: string, year: number, options?: any) {
        return FactBaseControllerApiFp(this.configuration).ingestQ4Facts(cik, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [numYearsToLookback] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseControllerApi
     */
    public runRssFilingIngestor(numYearsToLookback?: number, options?: any) {
        return FactBaseControllerApiFp(this.configuration).runRssFilingIngestor(numYearsToLookback, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactBaseUnsecuredControllerApi - axios parameter creator
 * @export
 */
export const FactBaseUnsecuredControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries: async (factId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getAnnualTimeSeries', 'factId', factId)
            const localVarPath = `/public/fact-base/{factId}/time-series`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} factIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries1: async (factIds: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factIds' is not null or undefined
            assertParamExists('getAnnualTimeSeries1', 'factIds', factIds)
            const localVarPath = `/public/fact-base/time-series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (factIds) {
                localVarQueryParameter['factIds'] = factIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFact: async (factId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getFact', 'factId', factId)
            const localVarPath = `/public/fact-base/{factId}`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactBaseUnsecuredControllerApi - functional programming interface
 * @export
 */
export const FactBaseUnsecuredControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactBaseUnsecuredControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnualTimeSeries(factId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnualTimeSeries(factId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} factIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnualTimeSeries1(factIds: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregatedFact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnualTimeSeries1(factIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFact(factId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFact(factId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactBaseUnsecuredControllerApi - factory interface
 * @export
 */
export const FactBaseUnsecuredControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactBaseUnsecuredControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries(factId: string, options?: any): AxiosPromise<Array<Fact>> {
            return localVarFp.getAnnualTimeSeries(factId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} factIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries1(factIds: Array<string>, options?: any): AxiosPromise<Array<AggregatedFact>> {
            return localVarFp.getAnnualTimeSeries1(factIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFact(factId: string, options?: any): AxiosPromise<Fact> {
            return localVarFp.getFact(factId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactBaseUnsecuredControllerApi - object-oriented interface
 * @export
 * @class FactBaseUnsecuredControllerApi
 * @extends {BaseAPI}
 */
export class FactBaseUnsecuredControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} factId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseUnsecuredControllerApi
     */
    public getAnnualTimeSeries(factId: string, options?: any) {
        return FactBaseUnsecuredControllerApiFp(this.configuration).getAnnualTimeSeries(factId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} factIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseUnsecuredControllerApi
     */
    public getAnnualTimeSeries1(factIds: Array<string>, options?: any) {
        return FactBaseUnsecuredControllerApiFp(this.configuration).getAnnualTimeSeries1(factIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} factId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseUnsecuredControllerApi
     */
    public getFact(factId: string, options?: any) {
        return FactBaseUnsecuredControllerApiFp(this.configuration).getFact(factId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilingEntityManagerControllerApi - axios parameter creator
 * @export
 */
export const FilingEntityManagerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bootstrapFilingEntity: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('bootstrapFilingEntity', 'cik', cik)
            const localVarPath = `/api/filing-entity-manager/{cik}`
                .replace(`{${"cik"}}`, encodeURIComponent(String(cik)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bootstrapFilingEntitySync: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('bootstrapFilingEntitySync', 'cik', cik)
            const localVarPath = `/api/filing-entity-manager/{cik}/sync`
                .replace(`{${"cik"}}`, encodeURIComponent(String(cik)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilingEntity: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('createFilingEntity', 'cik', cik)
            const localVarPath = `/api/filing-entity-manager/{cik}/create`
                .replace(`{${"cik"}}`, encodeURIComponent(String(cik)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FilingEntity} filingEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilingEntity: async (filingEntity: FilingEntity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filingEntity' is not null or undefined
            assertParamExists('saveFilingEntity', 'filingEntity', filingEntity)
            const localVarPath = `/api/filing-entity-manager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filingEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilingEntityManagerControllerApi - functional programming interface
 * @export
 */
export const FilingEntityManagerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilingEntityManagerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bootstrapFilingEntity(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bootstrapFilingEntity(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bootstrapFilingEntitySync(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bootstrapFilingEntitySync(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFilingEntity(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFilingEntity(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FilingEntity} filingEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFilingEntity(filingEntity: FilingEntity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFilingEntity(filingEntity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilingEntityManagerControllerApi - factory interface
 * @export
 */
export const FilingEntityManagerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilingEntityManagerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bootstrapFilingEntity(cik: string, options?: any): AxiosPromise<FilingEntity> {
            return localVarFp.bootstrapFilingEntity(cik, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bootstrapFilingEntitySync(cik: string, options?: any): AxiosPromise<FilingEntity> {
            return localVarFp.bootstrapFilingEntitySync(cik, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilingEntity(cik: string, options?: any): AxiosPromise<FilingEntity> {
            return localVarFp.createFilingEntity(cik, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FilingEntity} filingEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilingEntity(filingEntity: FilingEntity, options?: any): AxiosPromise<void> {
            return localVarFp.saveFilingEntity(filingEntity, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilingEntityManagerControllerApi - object-oriented interface
 * @export
 * @class FilingEntityManagerControllerApi
 * @extends {BaseAPI}
 */
export class FilingEntityManagerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerControllerApi
     */
    public bootstrapFilingEntity(cik: string, options?: any) {
        return FilingEntityManagerControllerApiFp(this.configuration).bootstrapFilingEntity(cik, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerControllerApi
     */
    public bootstrapFilingEntitySync(cik: string, options?: any) {
        return FilingEntityManagerControllerApiFp(this.configuration).bootstrapFilingEntitySync(cik, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerControllerApi
     */
    public createFilingEntity(cik: string, options?: any) {
        return FilingEntityManagerControllerApiFp(this.configuration).createFilingEntity(cik, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FilingEntity} filingEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerControllerApi
     */
    public saveFilingEntity(filingEntity: FilingEntity, options?: any) {
        return FilingEntityManagerControllerApiFp(this.configuration).saveFilingEntity(filingEntity, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilingEntityManagerUnsecuredControllerApi - axios parameter creator
 * @export
 */
export const FilingEntityManagerUnsecuredControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilingEntity: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('getFilingEntity', 'cik', cik)
            const localVarPath = `/public/filing-entity-manager/{cik}`
                .replace(`{${"cik"}}`, encodeURIComponent(String(cik)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilingEntityManagerUnsecuredControllerApi - functional programming interface
 * @export
 */
export const FilingEntityManagerUnsecuredControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilingEntityManagerUnsecuredControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilingEntity(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilingEntity(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilingEntityManagerUnsecuredControllerApi - factory interface
 * @export
 */
export const FilingEntityManagerUnsecuredControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilingEntityManagerUnsecuredControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilingEntity(cik: string, options?: any): AxiosPromise<FilingEntity> {
            return localVarFp.getFilingEntity(cik, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilingEntityManagerUnsecuredControllerApi - object-oriented interface
 * @export
 * @class FilingEntityManagerUnsecuredControllerApi
 * @extends {BaseAPI}
 */
export class FilingEntityManagerUnsecuredControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerUnsecuredControllerApi
     */
    public getFilingEntity(cik: string, options?: any) {
        return FilingEntityManagerUnsecuredControllerApiFp(this.configuration).getFilingEntity(cik, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MarketingControllerApi - axios parameter creator
 * @export
 */
export const MarketingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EarlyAccessRequest} earlyAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earlyAccessRequests: async (earlyAccessRequest: EarlyAccessRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'earlyAccessRequest' is not null or undefined
            assertParamExists('earlyAccessRequests', 'earlyAccessRequest', earlyAccessRequest)
            const localVarPath = `/public/marketing/early-access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(earlyAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedback20210329: async (feedback: Feedback, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedback' is not null or undefined
            assertParamExists('feedback20210329', 'feedback', feedback)
            const localVarPath = `/public/marketing/2021-03-29/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StockAnalysisInterest} stockAnalysisInterest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisInterest: async (stockAnalysisInterest: StockAnalysisInterest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisInterest' is not null or undefined
            assertParamExists('stockAnalysisInterest', 'stockAnalysisInterest', stockAnalysisInterest)
            const localVarPath = `/public/marketing/stock-analysis-interest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysisInterest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisRequest: async (stockAnalysisRequest: Array<StockAnalysisRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisRequest' is not null or undefined
            assertParamExists('stockAnalysisRequest', 'stockAnalysisRequest', stockAnalysisRequest)
            const localVarPath = `/public/marketing/stock-analysis-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketingControllerApi - functional programming interface
 * @export
 */
export const MarketingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EarlyAccessRequest} earlyAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earlyAccessRequests(earlyAccessRequest: EarlyAccessRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earlyAccessRequests(earlyAccessRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedback20210329(feedback: Feedback, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedback20210329(feedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StockAnalysisInterest} stockAnalysisInterest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockAnalysisInterest(stockAnalysisInterest: StockAnalysisInterest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockAnalysisInterest(stockAnalysisInterest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockAnalysisRequest(stockAnalysisRequest: Array<StockAnalysisRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockAnalysisRequest(stockAnalysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MarketingControllerApi - factory interface
 * @export
 */
export const MarketingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {EarlyAccessRequest} earlyAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earlyAccessRequests(earlyAccessRequest: EarlyAccessRequest, options?: any): AxiosPromise<void> {
            return localVarFp.earlyAccessRequests(earlyAccessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedback20210329(feedback: Feedback, options?: any): AxiosPromise<void> {
            return localVarFp.feedback20210329(feedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StockAnalysisInterest} stockAnalysisInterest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisInterest(stockAnalysisInterest: StockAnalysisInterest, options?: any): AxiosPromise<void> {
            return localVarFp.stockAnalysisInterest(stockAnalysisInterest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisRequest(stockAnalysisRequest: Array<StockAnalysisRequest>, options?: any): AxiosPromise<void> {
            return localVarFp.stockAnalysisRequest(stockAnalysisRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketingControllerApi - object-oriented interface
 * @export
 * @class MarketingControllerApi
 * @extends {BaseAPI}
 */
export class MarketingControllerApi extends BaseAPI {
    /**
     * 
     * @param {EarlyAccessRequest} earlyAccessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public earlyAccessRequests(earlyAccessRequest: EarlyAccessRequest, options?: any) {
        return MarketingControllerApiFp(this.configuration).earlyAccessRequests(earlyAccessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Feedback} feedback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public feedback20210329(feedback: Feedback, options?: any) {
        return MarketingControllerApiFp(this.configuration).feedback20210329(feedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StockAnalysisInterest} stockAnalysisInterest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public stockAnalysisInterest(stockAnalysisInterest: StockAnalysisInterest, options?: any) {
        return MarketingControllerApiFp(this.configuration).stockAnalysisInterest(stockAnalysisInterest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public stockAnalysisRequest(stockAnalysisRequest: Array<StockAnalysisRequest>, options?: any) {
        return MarketingControllerApiFp(this.configuration).stockAnalysisRequest(stockAnalysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MxParserControllerApi - axios parameter creator
 * @export
 */
export const MxParserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (mxParserEvaluateRequest: MxParserEvaluateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mxParserEvaluateRequest' is not null or undefined
            assertParamExists('evaluate', 'mxParserEvaluateRequest', mxParserEvaluateRequest)
            const localVarPath = `/api/mxparser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mxParserEvaluateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MxParserControllerApi - functional programming interface
 * @export
 */
export const MxParserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MxParserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(mxParserEvaluateRequest: MxParserEvaluateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MxParserEvaluateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(mxParserEvaluateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MxParserControllerApi - factory interface
 * @export
 */
export const MxParserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MxParserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(mxParserEvaluateRequest: MxParserEvaluateRequest, options?: any): AxiosPromise<MxParserEvaluateResponse> {
            return localVarFp.evaluate(mxParserEvaluateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MxParserControllerApi - object-oriented interface
 * @export
 * @class MxParserControllerApi
 * @extends {BaseAPI}
 */
export class MxParserControllerApi extends BaseAPI {
    /**
     * 
     * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MxParserControllerApi
     */
    public evaluate(mxParserEvaluateRequest: MxParserEvaluateRequest, options?: any) {
        return MxParserControllerApiFp(this.configuration).evaluate(mxParserEvaluateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublishedStockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const PublishedStockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses: async (userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublishedStockAnalysis', 'id', id)
            const localVarPath = `/public/published-stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - functional programming interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublishedStockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - factory interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublishedStockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getPublishedStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublishedStockAnalysisControllerApi - object-oriented interface
 * @export
 * @class PublishedStockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class PublishedStockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public getPublishedStockAnalysis(id: string, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).getPublishedStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis: async (evaluateModelRequest: EvaluateModelRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluateModelRequest' is not null or undefined
            assertParamExists('evaluateStockAnalysis', 'evaluateModelRequest', evaluateModelRequest)
            const localVarPath = `/api/stock-analyzer/stock-analyses/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluateModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses: async (published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStockAnalysis: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('refreshStockAnalysis', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/stock-analyzer/stock-analyses/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStockAnalysis: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('saveStockAnalysis', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/unpublish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluateModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateStockAnalysis(evaluateModelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshStockAnalysis(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveStockAnalysis(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisControllerApi - factory interface
 * @export
 */
export const StockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any): AxiosPromise<EvaluateModelResponse> {
            return localVarFp.evaluateStockAnalysis(evaluateModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.publish(id, options).then((request) => request(axios, basePath));
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.refreshStockAnalysis(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<void> {
            return localVarFp.saveStockAnalysis(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.unpublish(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public deleteStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).deleteStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
     * @param {EvaluateModelRequest} evaluateModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).evaluateStockAnalysis(evaluateModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [published] 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).findStockAnalyses(published, userId, cik, ticker, skip, limit, term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public getStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).getStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public publish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).publish(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).refreshStockAnalysis(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).saveStockAnalysis(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public unpublish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).unpublish(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisExcelDownloaderControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisExcelDownloaderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('download', 'id', id)
            const localVarPath = `/api/stock-analyzer/workflow/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisExcelDownloaderControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisExcelDownloaderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisExcelDownloaderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisExcelDownloaderControllerApi - factory interface
 * @export
 */
export const StockAnalysisExcelDownloaderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisExcelDownloaderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.download(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisExcelDownloaderControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisExcelDownloaderControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisExcelDownloaderControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisExcelDownloaderControllerApi
     */
    public download(id: string, options?: any) {
        return StockAnalysisExcelDownloaderControllerApiFp(this.configuration).download(id, options).then((request) => request(this.axios, this.basePath));
    }
}


