/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street1?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street2?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    stateOrCountry?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipCode?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    stateOrCountryDescription?: string;
}
/**
 * 
 * @export
 * @interface AggregatedFact
 */
export interface AggregatedFact {
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregatedFact
     */
    factIds: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof AggregatedFact
     */
    value: number;
    /**
     * 
     * @type {string}
     * @memberof AggregatedFact
     */
    conceptName: string;
    /**
     * 
     * @type {string}
     * @memberof AggregatedFact
     */
    documentFiscalPeriodFocus?: AggregatedFactDocumentFiscalPeriodFocusEnum;
    /**
     * 
     * @type {string}
     * @memberof AggregatedFact
     */
    documentPeriodEndDate: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AggregatedFactDocumentFiscalPeriodFocusEnum {
    Fy = 'FY',
    Q1 = 'Q1',
    Q2 = 'Q2',
    Q3 = 'Q3',
    Q4 = 'Q4',
    Na = 'NA'
}

/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    period: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    name: string;
    /**
     * 
     * @type {Item}
     * @memberof Cell
     */
    item: Item;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    formula?: string;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    excelFormula?: string;
    /**
     * 
     * @type {Address}
     * @memberof Cell
     */
    address?: Address;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cell
     */
    dependentCellNames: Array<string>;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    stockAnalysisId: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    text: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Commentary
 */
export interface Commentary {
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    commentary?: string;
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    generatorClass?: string;
}
/**
 * 
 * @export
 * @interface CompanyKPIs
 */
export interface CompanyKPIs {
    /**
     * 
     * @type {string}
     * @memberof CompanyKPIs
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof CompanyKPIs
     */
    cik: string;
    /**
     * 
     * @type {Array<KPIMetadata>}
     * @memberof CompanyKPIs
     */
    kpis: Array<KPIMetadata>;
    /**
     * 
     * @type {string}
     * @memberof CompanyKPIs
     */
    revenueItemName: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof CompanyKPIs
     */
    items: Array<Item>;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof CompanyKPIs
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {number}
     * @memberof CompanyKPIs
     */
    projectionPeriods: number;
}
/**
 * 
 * @export
 * @interface Component
 */
export interface Component {
    /**
     * 
     * @type {number}
     * @memberof Component
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof Component
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface CompoundedGrowth
 */
export interface CompoundedGrowth {
    /**
     * 
     * @type {number}
     * @memberof CompoundedGrowth
     */
    growthRate: number;
}
/**
 * 
 * @export
 * @interface DerivedStockAnalytics
 */
export interface DerivedStockAnalytics {
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    zeroGrowthPrice?: number;
    /**
     * 
     * @type {{ [key: string]: Waterfall; }}
     * @memberof DerivedStockAnalytics
     */
    businessWaterfall: { [key: string]: Waterfall; };
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    shareOutstanding: Item;
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    profitPerShare: Item;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    targetPrice: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    finalPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    discountRate: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    revenueCAGR: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    currentPrice: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    irr?: number;
}
/**
 * 
 * @export
 * @interface EarlyAccessRequest
 */
export interface EarlyAccessRequest {
    /**
     * 
     * @type {string}
     * @memberof EarlyAccessRequest
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof EarlyAccessRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof EarlyAccessRequest
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface EdgarEntity
 */
export interface EdgarEntity {
    /**
     * 
     * @type {string}
     * @memberof EdgarEntity
     */
    get_id?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntity
     */
    get_index?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntity
     */
    get_type?: string;
    /**
     * 
     * @type {EdgarEntitySource}
     * @memberof EdgarEntity
     */
    get_source: EdgarEntitySource;
}
/**
 * 
 * @export
 * @interface EdgarEntitySource
 */
export interface EdgarEntitySource {
    /**
     * 
     * @type {string}
     * @memberof EdgarEntitySource
     */
    entity: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntitySource
     */
    entity_words: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarEntitySource
     */
    tickers?: string;
    /**
     * 
     * @type {number}
     * @memberof EdgarEntitySource
     */
    rank?: number;
}
/**
 * 
 * @export
 * @interface EdgarFilingMetadata
 */
export interface EdgarFilingMetadata {
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    ciks: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    period_ending: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    root_form?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    file_num: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    display_names: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    sequence?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    biz_states: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    sics: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    form: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    adsh: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    biz_locations: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    file_date: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    file_type?: string;
    /**
     * 
     * @type {string}
     * @memberof EdgarFilingMetadata
     */
    file_description?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof EdgarFilingMetadata
     */
    inc_states: Array<string>;
}
/**
 * 
 * @export
 * @interface EvaluateModelRequest
 */
export interface EvaluateModelRequest {
    /**
     * 
     * @type {Model}
     * @memberof EvaluateModelRequest
     */
    model: Model;
}
/**
 * 
 * @export
 * @interface EvaluateModelResponse
 */
export interface EvaluateModelResponse {
    /**
     * 
     * @type {Model}
     * @memberof EvaluateModelResponse
     */
    model: Model;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof EvaluateModelResponse
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof EvaluateModelResponse
     */
    derivedStockAnalytics: DerivedStockAnalytics;
}
/**
 * 
 * @export
 * @interface Fact
 */
export interface Fact {
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    instanceDocumentElementId: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    instanceDocumentElementName: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    cik: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    adsh: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    entityName: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    primarySymbol: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    formType: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    conceptName: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    conceptHref: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    namespace: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    instant?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    documentFiscalPeriodFocus: FactDocumentFiscalPeriodFocusEnum;
    /**
     * 
     * @type {number}
     * @memberof Fact
     */
    documentFiscalYearFocus: number;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    documentPeriodEndDate: string;
    /**
     * 
     * @type {Array<XbrlExplicitMember>}
     * @memberof Fact
     */
    explicitMembers: Array<XbrlExplicitMember>;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    sourceDocument: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    verboseLabel?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    labelTerse?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    documentation?: string;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    stringValue: string;
    /**
     * 
     * @type {number}
     * @memberof Fact
     */
    doubleValue?: number;
    /**
     * 
     * @type {string}
     * @memberof Fact
     */
    lastUpdated: string;
}

/**
    * @export
    * @enum {string}
    */
export enum FactDocumentFiscalPeriodFocusEnum {
    Fy = 'FY',
    Q1 = 'Q1',
    Q2 = 'Q2',
    Q3 = 'Q3',
    Q4 = 'Q4',
    Na = 'NA'
}

/**
 * 
 * @export
 * @interface FactTimeSeries
 */
export interface FactTimeSeries {
    /**
     * 
     * @type {Array<Fact>}
     * @memberof FactTimeSeries
     */
    facts: Array<Fact>;
    /**
     * 
     * @type {string}
     * @memberof FactTimeSeries
     */
    conceptName: string;
    /**
     * 
     * @type {string}
     * @memberof FactTimeSeries
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof FactTimeSeries
     */
    startDate: string;
    /**
     * 
     * @type {string}
     * @memberof FactTimeSeries
     */
    stopDate: string;
    /**
     * 
     * @type {string}
     * @memberof FactTimeSeries
     */
    documentFiscalPeriodFocus: FactTimeSeriesDocumentFiscalPeriodFocusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FactTimeSeriesDocumentFiscalPeriodFocusEnum {
    Fy = 'FY',
    Q1 = 'Q1',
    Q2 = 'Q2',
    Q3 = 'Q3',
    Q4 = 'Q4',
    Na = 'NA'
}

/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    get_id: string;
    /**
     * 
     * @type {object}
     * @memberof Feedback
     */
    body: object;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    version: string;
}
/**
 * 
 * @export
 * @interface FilingEntity
 */
export interface FilingEntity {
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    cik: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    tradingSymbol?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    entityType?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    sic?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    sicDescription?: string;
    /**
     * 
     * @type {number}
     * @memberof FilingEntity
     */
    insiderTransactionForOwnerExists?: number;
    /**
     * 
     * @type {number}
     * @memberof FilingEntity
     */
    insiderTransactionForIssuerExists?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilingEntity
     */
    tickers: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FilingEntity
     */
    exchanges: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    ein?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    website?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    investorWebsite?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    fiscalYearEnd?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    stateOfIncorporation?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    stateOfIncorporationDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    phone?: string;
    /**
     * 
     * @type {Address}
     * @memberof FilingEntity
     */
    businessAddress?: Address;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    statusMessage?: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    lastUpdated: string;
    /**
     * 
     * @type {string}
     * @memberof FilingEntity
     */
    latestAdsh?: string;
}
/**
 * 
 * @export
 * @interface FindStockAnalysisResponse
 */
export interface FindStockAnalysisResponse {
    /**
     * 
     * @type {Array<StockAnalysisProjection>}
     * @memberof FindStockAnalysisResponse
     */
    stockAnalyses: Array<StockAnalysisProjection>;
}
/**
 * 
 * @export
 * @interface FixedCost
 */
export interface FixedCost {
    /**
     * 
     * @type {number}
     * @memberof FixedCost
     */
    cost: number;
}
/**
 * 
 * @export
 * @interface FixedCostAutoFill
 */
export interface FixedCostAutoFill {
    /**
     * 
     * @type {string}
     * @memberof FixedCostAutoFill
     */
    label: string;
    /**
     * 
     * @type {FixedCost}
     * @memberof FixedCostAutoFill
     */
    fixedCost: FixedCost;
}
/**
 * 
 * @export
 * @interface HistoricalValue
 */
export interface HistoricalValue {
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    factId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HistoricalValue
     */
    factIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    conceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentFiscalPeriodFocus?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    documentFiscalYearFocus?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentPeriodEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    instant?: string;
}
/**
 * 
 * @export
 * @interface Issue
 */
export interface Issue {
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    stockAnalysisId: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    itemName?: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    issueType: IssueIssueTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    message: string;
    /**
     * 
     * @type {string}
     * @memberof Issue
     */
    createdAt: string;
}

/**
    * @export
    * @enum {string}
    */
export enum IssueIssueTypeEnum {
    RevenueItemNotFound = 'RevenueItemNotFound',
    NetIncomeItemNotFound = 'NetIncomeItemNotFound',
    SharesOutstandingItemNotFound = 'SharesOutstandingItemNotFound',
    EpsItemNotFound = 'EpsItemNotFound'
}

/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    type: ItemTypeEnum;
    /**
     * 
     * @type {HistoricalValue}
     * @memberof Item
     */
    historicalValue?: HistoricalValue;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    formula: string;
    /**
     * 
     * @type {SumOfOtherItems}
     * @memberof Item
     */
    sumOfOtherItems?: SumOfOtherItems;
    /**
     * 
     * @type {ProductOfOtherItems}
     * @memberof Item
     */
    productOfOtherItems?: ProductOfOtherItems;
    /**
     * 
     * @type {ManualProjections}
     * @memberof Item
     */
    manualProjections?: ManualProjections;
    /**
     * 
     * @type {PercentOfRevenue}
     * @memberof Item
     */
    percentOfRevenue?: PercentOfRevenue;
    /**
     * 
     * @type {PercentOfAnotherItem}
     * @memberof Item
     */
    percentOfAnotherItem?: PercentOfAnotherItem;
    /**
     * 
     * @type {CompoundedGrowth}
     * @memberof Item
     */
    compoundedGrowth?: CompoundedGrowth;
    /**
     * 
     * @type {FixedCost}
     * @memberof Item
     */
    fixedCost?: FixedCost;
    /**
     * 
     * @type {Commentary}
     * @memberof Item
     */
    commentaries?: Commentary;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemTypeEnum {
    CompoundedGrowth = 'CompoundedGrowth',
    SumOfOtherItems = 'SumOfOtherItems',
    ProductOfOtherItems = 'ProductOfOtherItems',
    Custom = 'Custom',
    Discrete = 'Discrete',
    ManualProjections = 'ManualProjections',
    PercentOfRevenue = 'PercentOfRevenue',
    PercentOfAnotherItem = 'PercentOfAnotherItem',
    FixedCost = 'FixedCost'
}

/**
 * 
 * @export
 * @interface KPIMetadata
 */
export interface KPIMetadata {
    /**
     * 
     * @type {string}
     * @memberof KPIMetadata
     */
    itemName: string;
    /**
     * 
     * @type {string}
     * @memberof KPIMetadata
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof KPIMetadata
     */
    format: KPIMetadataFormatEnum;
    /**
     * 
     * @type {boolean}
     * @memberof KPIMetadata
     */
    collapse?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum KPIMetadataFormatEnum {
    Money = 'MONEY',
    Percent = 'PERCENT',
    Number = 'NUMBER'
}

/**
 * 
 * @export
 * @interface ManualProjection
 */
export interface ManualProjection {
    /**
     * 
     * @type {number}
     * @memberof ManualProjection
     */
    fiscalYear: number;
    /**
     * 
     * @type {number}
     * @memberof ManualProjection
     */
    value: number;
}
/**
 * 
 * @export
 * @interface ManualProjections
 */
export interface ManualProjections {
    /**
     * 
     * @type {Array<ManualProjection>}
     * @memberof ManualProjections
     */
    manualProjections: Array<ManualProjection>;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    adsh?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    name?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    itemOverrides: Array<Item>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Model
     */
    suppressedItems: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    totalRevenueConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    epsConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    netIncomeConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    sharesOutstandingConceptName?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    incomeStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    balanceSheetItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    cashFlowStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    otherItems: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    beta: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    riskFreeRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    equityRiskPremium: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    terminalGrowthRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    periods: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelColumnOffset: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelRowOffset: number;
}
/**
 * 
 * @export
 * @interface ModelRevenueRequest
 */
export interface ModelRevenueRequest {
    /**
     * 
     * @type {RevenueModel}
     * @memberof ModelRevenueRequest
     */
    revenueModel: RevenueModel;
    /**
     * 
     * @type {Model}
     * @memberof ModelRevenueRequest
     */
    model: Model;
}
/**
 * 
 * @export
 * @interface MxParserEvaluateRequest
 */
export interface MxParserEvaluateRequest {
    /**
     * 
     * @type {string}
     * @memberof MxParserEvaluateRequest
     */
    formula: string;
}
/**
 * 
 * @export
 * @interface MxParserEvaluateResponse
 */
export interface MxParserEvaluateResponse {
    /**
     * 
     * @type {number}
     * @memberof MxParserEvaluateResponse
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof MxParserEvaluateResponse
     */
    error?: string;
}
/**
 * 
 * @export
 * @interface PercentOfAnotherItem
 */
export interface PercentOfAnotherItem {
    /**
     * 
     * @type {string}
     * @memberof PercentOfAnotherItem
     */
    itemName: string;
    /**
     * 
     * @type {number}
     * @memberof PercentOfAnotherItem
     */
    percent: number;
}
/**
 * 
 * @export
 * @interface PercentOfAnotherItemAutoFill
 */
export interface PercentOfAnotherItemAutoFill {
    /**
     * 
     * @type {string}
     * @memberof PercentOfAnotherItemAutoFill
     */
    label: string;
    /**
     * 
     * @type {PercentOfAnotherItem}
     * @memberof PercentOfAnotherItemAutoFill
     */
    percentOfAnotherItem: PercentOfAnotherItem;
}
/**
 * 
 * @export
 * @interface PercentOfRevenue
 */
export interface PercentOfRevenue {
    /**
     * 
     * @type {number}
     * @memberof PercentOfRevenue
     */
    percentOfRevenue: number;
}
/**
 * 
 * @export
 * @interface PercentOfRevenueAutoFill
 */
export interface PercentOfRevenueAutoFill {
    /**
     * 
     * @type {string}
     * @memberof PercentOfRevenueAutoFill
     */
    label: string;
    /**
     * 
     * @type {PercentOfRevenue}
     * @memberof PercentOfRevenueAutoFill
     */
    percentOfRevenue: PercentOfRevenue;
}
/**
 * 
 * @export
 * @interface ProductComponent
 */
export interface ProductComponent {
    /**
     * 
     * @type {string}
     * @memberof ProductComponent
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface ProductOfOtherItems
 */
export interface ProductOfOtherItems {
    /**
     * 
     * @type {Array<ProductComponent>}
     * @memberof ProductOfOtherItems
     */
    components: Array<ProductComponent>;
}
/**
 * 
 * @export
 * @interface RevenueModel
 */
export interface RevenueModel {
    /**
     * 
     * @type {string}
     * @memberof RevenueModel
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof RevenueModel
     */
    revenueDriverType?: RevenueModelRevenueDriverTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RevenueModel
     */
    stockAnalysisId: string;
    /**
     * 
     * @type {number}
     * @memberof RevenueModel
     */
    terminalFiscalYear?: number;
    /**
     * 
     * @type {number}
     * @memberof RevenueModel
     */
    terminalYearAverageRevenuePerUser?: number;
    /**
     * 
     * @type {number}
     * @memberof RevenueModel
     */
    terminalYearActiveUser?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum RevenueModelRevenueDriverTypeEnum {
    ZacksEstimates = 'ZacksEstimates',
    AverageRevenuePerUserTimesActiveUser = 'AverageRevenuePerUserTimesActiveUser'
}

/**
 * 
 * @export
 * @interface StockAnalysis2
 */
export interface StockAnalysis2 {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    ticker?: string;
    /**
     * 
     * @type {Model}
     * @memberof StockAnalysis2
     */
    model: Model;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof StockAnalysis2
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof StockAnalysis2
     */
    derivedStockAnalytics?: DerivedStockAnalytics;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    userId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysis2
     */
    tags: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysis2
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface StockAnalysisInterest
 */
export interface StockAnalysisInterest {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisInterest
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisInterest
     */
    email: string;
    /**
     * 
     * @type {Array<StockAnalysisRequest>}
     * @memberof StockAnalysisInterest
     */
    requests: Array<StockAnalysisRequest>;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisInterest
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface StockAnalysisProjection
 */
export interface StockAnalysisProjection {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    ticker?: string;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    currentPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    targetPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    finalPrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysisProjection
     */
    published?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysisProjection
     */
    tags: Array<string>;
}
/**
 * 
 * @export
 * @interface StockAnalysisRequest
 */
export interface StockAnalysisRequest {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    cik: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    ticker: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisRequest
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface SumOfOtherItems
 */
export interface SumOfOtherItems {
    /**
     * 
     * @type {Array<Component>}
     * @memberof SumOfOtherItems
     */
    components: Array<Component>;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    createdAt: string;
}
/**
 * 
 * @export
 * @interface WatchList
 */
export interface WatchList {
    /**
     * 
     * @type {string}
     * @memberof WatchList
     */
    get_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WatchList
     */
    stockAnalysisIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WatchList
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface Waterfall
 */
export interface Waterfall {
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    revenue: Cell;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Waterfall
     */
    expenses: Array<Cell>;
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    profit: Cell;
}
/**
 * 
 * @export
 * @interface XbrlExplicitMember
 */
export interface XbrlExplicitMember {
    /**
     * 
     * @type {string}
     * @memberof XbrlExplicitMember
     */
    dimension: string;
    /**
     * 
     * @type {string}
     * @memberof XbrlExplicitMember
     */
    value: string;
}
/**
 * 
 * @export
 * @interface ZacksSalesEstimates
 */
export interface ZacksSalesEstimates {
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    file_prod_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    m_ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    comp_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    comp_name_2?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    exchange?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    currency_code?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    per_end_date?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    per_type?: string;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    per_code?: string;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    per_fisc_year?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    per_fisc_qtr?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    per_cal_year?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    per_cal_qtr?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    ann_rpt_flag?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    qtr_rpt_flag?: number;
    /**
     * 
     * @type {string}
     * @memberof ZacksSalesEstimates
     */
    last_rev_date?: string;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_mean_est?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_median_est?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_high_est?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_low_est?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_std_dev_est?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_pct_chg_est_1w?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est_rev_up_1w?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est_rev_down_1w?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_pct_chg_est_1m?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est_rev_up_1m?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est_rev_down_1m?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_pct_chg_est_3m?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est_rev_up_3m?: number;
    /**
     * 
     * @type {number}
     * @memberof ZacksSalesEstimates
     */
    sales_cnt_est_rev_down_3m?: number;
}

/**
 * CommentsControllerApi - axios parameter creator
 * @export
 */
export const CommentsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('getComments', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/public/comments/{stockAnalysisId}`
                .replace(`{${"stockAnalysisId"}}`, encodeURIComponent(String(stockAnalysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment: async (comment: Comment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'comment' is not null or undefined
            assertParamExists('postComment', 'comment', comment)
            const localVarPath = `/public/comments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(comment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentsControllerApi - functional programming interface
 * @export
 */
export const CommentsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getComments(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getComments(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postComment(comment: Comment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postComment(comment, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommentsControllerApi - factory interface
 * @export
 */
export const CommentsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(stockAnalysisId: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.getComments(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Comment} comment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postComment(comment: Comment, options?: any): AxiosPromise<void> {
            return localVarFp.postComment(comment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentsControllerApi - object-oriented interface
 * @export
 * @class CommentsControllerApi
 * @extends {BaseAPI}
 */
export class CommentsControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsControllerApi
     */
    public getComments(stockAnalysisId: string, options?: any) {
        return CommentsControllerApiFp(this.configuration).getComments(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Comment} comment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentsControllerApi
     */
    public postComment(comment: Comment, options?: any) {
        return CommentsControllerApiFp(this.configuration).postComment(comment, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CompanyKpIsControllerApi - axios parameter creator
 * @export
 */
export const CompanyKpIsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CompanyKPIs} companyKPIs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCompanyKPIs: async (companyKPIs: CompanyKPIs, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyKPIs' is not null or undefined
            assertParamExists('evaluateCompanyKPIs', 'companyKPIs', companyKPIs)
            const localVarPath = `/api/company-kpis/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyKPIs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyKPIs: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCompanyKPIs', 'id', id)
            const localVarPath = `/api/company-kpis/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompanyKPIs} companyKPIs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCompanyKPIs: async (companyKPIs: CompanyKPIs, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyKPIs' is not null or undefined
            assertParamExists('saveCompanyKPIs', 'companyKPIs', companyKPIs)
            const localVarPath = `/api/company-kpis`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(companyKPIs, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CompanyKpIsControllerApi - functional programming interface
 * @export
 */
export const CompanyKpIsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CompanyKpIsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CompanyKPIs} companyKPIs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateCompanyKPIs(companyKPIs: CompanyKPIs, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyKPIs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateCompanyKPIs(companyKPIs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCompanyKPIs(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CompanyKPIs>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCompanyKPIs(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CompanyKPIs} companyKPIs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveCompanyKPIs(companyKPIs: CompanyKPIs, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveCompanyKPIs(companyKPIs, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CompanyKpIsControllerApi - factory interface
 * @export
 */
export const CompanyKpIsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CompanyKpIsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CompanyKPIs} companyKPIs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCompanyKPIs(companyKPIs: CompanyKPIs, options?: any): AxiosPromise<CompanyKPIs> {
            return localVarFp.evaluateCompanyKPIs(companyKPIs, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCompanyKPIs(id: string, options?: any): AxiosPromise<CompanyKPIs> {
            return localVarFp.getCompanyKPIs(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompanyKPIs} companyKPIs 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveCompanyKPIs(companyKPIs: CompanyKPIs, options?: any): AxiosPromise<void> {
            return localVarFp.saveCompanyKPIs(companyKPIs, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CompanyKpIsControllerApi - object-oriented interface
 * @export
 * @class CompanyKpIsControllerApi
 * @extends {BaseAPI}
 */
export class CompanyKpIsControllerApi extends BaseAPI {
    /**
     * 
     * @param {CompanyKPIs} companyKPIs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyKpIsControllerApi
     */
    public evaluateCompanyKPIs(companyKPIs: CompanyKPIs, options?: any) {
        return CompanyKpIsControllerApiFp(this.configuration).evaluateCompanyKPIs(companyKPIs, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyKpIsControllerApi
     */
    public getCompanyKPIs(id: string, options?: any) {
        return CompanyKpIsControllerApiFp(this.configuration).getCompanyKPIs(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompanyKPIs} companyKPIs 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CompanyKpIsControllerApi
     */
    public saveCompanyKPIs(companyKPIs: CompanyKPIs, options?: any) {
        return CompanyKpIsControllerApiFp(this.configuration).saveCompanyKPIs(companyKPIs, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EdgarExplorerControllerApi - axios parameter creator
 * @export
 */
export const EdgarExplorerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities: async (term: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchEntities', 'term', term)
            const localVarPath = `/public/edgar-explorer/entities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFilings: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('searchFilings', 'cik', cik)
            const localVarPath = `/public/edgar-explorer/filings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgarExplorerControllerApi - functional programming interface
 * @export
 */
export const EdgarExplorerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EdgarExplorerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchEntities(term: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdgarEntity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchEntities(term, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchFilings(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EdgarFilingMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFilings(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EdgarExplorerControllerApi - factory interface
 * @export
 */
export const EdgarExplorerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EdgarExplorerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchEntities(term: string, options?: any): AxiosPromise<Array<EdgarEntity>> {
            return localVarFp.searchEntities(term, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchFilings(cik: string, options?: any): AxiosPromise<Array<EdgarFilingMetadata>> {
            return localVarFp.searchFilings(cik, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EdgarExplorerControllerApi - object-oriented interface
 * @export
 * @class EdgarExplorerControllerApi
 * @extends {BaseAPI}
 */
export class EdgarExplorerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} term 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgarExplorerControllerApi
     */
    public searchEntities(term: string, options?: any) {
        return EdgarExplorerControllerApiFp(this.configuration).searchEntities(term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgarExplorerControllerApi
     */
    public searchFilings(cik: string, options?: any) {
        return EdgarExplorerControllerApiFp(this.configuration).searchFilings(cik, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactAutoFillerControllerApi - axios parameter creator
 * @export
 */
export const FactAutoFillerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFixedCostAutoFills: async (factId: string, model: Model, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getFixedCostAutoFills', 'factId', factId)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('getFixedCostAutoFills', 'model', model)
            const localVarPath = `/api/fact-auto-filler/{factId}/fixed-cost`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemName 
         * @param {string} dependentItemName 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentOfItemsAutoFills: async (itemName: string, dependentItemName: string, model: Model, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemName' is not null or undefined
            assertParamExists('getPercentOfItemsAutoFills', 'itemName', itemName)
            // verify required parameter 'dependentItemName' is not null or undefined
            assertParamExists('getPercentOfItemsAutoFills', 'dependentItemName', dependentItemName)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('getPercentOfItemsAutoFills', 'model', model)
            const localVarPath = `/api/fact-auto-filler/{itemName}/percent-of-another-item`
                .replace(`{${"itemName"}}`, encodeURIComponent(String(itemName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dependentItemName !== undefined) {
                localVarQueryParameter['dependentItemName'] = dependentItemName;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} itemName 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentOfRevenueAutoFills: async (itemName: string, model: Model, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemName' is not null or undefined
            assertParamExists('getPercentOfRevenueAutoFills', 'itemName', itemName)
            // verify required parameter 'model' is not null or undefined
            assertParamExists('getPercentOfRevenueAutoFills', 'model', model)
            const localVarPath = `/api/fact-auto-filler/{itemName}/percent-of-revenue`
                .replace(`{${"itemName"}}`, encodeURIComponent(String(itemName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactAutoFillerControllerApi - functional programming interface
 * @export
 */
export const FactAutoFillerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactAutoFillerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFixedCostAutoFills(factId: string, model: Model, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FixedCostAutoFill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFixedCostAutoFills(factId, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} itemName 
         * @param {string} dependentItemName 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPercentOfItemsAutoFills(itemName: string, dependentItemName: string, model: Model, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PercentOfAnotherItemAutoFill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPercentOfItemsAutoFills(itemName, dependentItemName, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} itemName 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPercentOfRevenueAutoFills(itemName: string, model: Model, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PercentOfRevenueAutoFill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPercentOfRevenueAutoFills(itemName, model, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactAutoFillerControllerApi - factory interface
 * @export
 */
export const FactAutoFillerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactAutoFillerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFixedCostAutoFills(factId: string, model: Model, options?: any): AxiosPromise<Array<FixedCostAutoFill>> {
            return localVarFp.getFixedCostAutoFills(factId, model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemName 
         * @param {string} dependentItemName 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentOfItemsAutoFills(itemName: string, dependentItemName: string, model: Model, options?: any): AxiosPromise<Array<PercentOfAnotherItemAutoFill>> {
            return localVarFp.getPercentOfItemsAutoFills(itemName, dependentItemName, model, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} itemName 
         * @param {Model} model 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPercentOfRevenueAutoFills(itemName: string, model: Model, options?: any): AxiosPromise<Array<PercentOfRevenueAutoFill>> {
            return localVarFp.getPercentOfRevenueAutoFills(itemName, model, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactAutoFillerControllerApi - object-oriented interface
 * @export
 * @class FactAutoFillerControllerApi
 * @extends {BaseAPI}
 */
export class FactAutoFillerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} factId 
     * @param {Model} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactAutoFillerControllerApi
     */
    public getFixedCostAutoFills(factId: string, model: Model, options?: any) {
        return FactAutoFillerControllerApiFp(this.configuration).getFixedCostAutoFills(factId, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemName 
     * @param {string} dependentItemName 
     * @param {Model} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactAutoFillerControllerApi
     */
    public getPercentOfItemsAutoFills(itemName: string, dependentItemName: string, model: Model, options?: any) {
        return FactAutoFillerControllerApiFp(this.configuration).getPercentOfItemsAutoFills(itemName, dependentItemName, model, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} itemName 
     * @param {Model} model 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactAutoFillerControllerApi
     */
    public getPercentOfRevenueAutoFills(itemName: string, model: Model, options?: any) {
        return FactAutoFillerControllerApiFp(this.configuration).getPercentOfRevenueAutoFills(itemName, model, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactBaseControllerApi - axios parameter creator
 * @export
 */
export const FactBaseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries: async (factId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getAnnualTimeSeries', 'factId', factId)
            const localVarPath = `/public/fact-base/{factId}/time-series`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} factIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries1: async (factIds: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factIds' is not null or undefined
            assertParamExists('getAnnualTimeSeries1', 'factIds', factIds)
            const localVarPath = `/public/fact-base/time-series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (factIds) {
                localVarQueryParameter['factIds'] = factIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFact: async (factId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getFact', 'factId', factId)
            const localVarPath = `/public/fact-base/{factId}`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactBaseControllerApi - functional programming interface
 * @export
 */
export const FactBaseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactBaseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnualTimeSeries(factId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Fact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnualTimeSeries(factId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} factIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnualTimeSeries1(factIds: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregatedFact>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnualTimeSeries1(factIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFact(factId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Fact>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFact(factId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactBaseControllerApi - factory interface
 * @export
 */
export const FactBaseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactBaseControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries(factId: string, options?: any): AxiosPromise<Array<Fact>> {
            return localVarFp.getAnnualTimeSeries(factId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} factIds 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnualTimeSeries1(factIds: Array<string>, options?: any): AxiosPromise<Array<AggregatedFact>> {
            return localVarFp.getAnnualTimeSeries1(factIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} factId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFact(factId: string, options?: any): AxiosPromise<Fact> {
            return localVarFp.getFact(factId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactBaseControllerApi - object-oriented interface
 * @export
 * @class FactBaseControllerApi
 * @extends {BaseAPI}
 */
export class FactBaseControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} factId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseControllerApi
     */
    public getAnnualTimeSeries(factId: string, options?: any) {
        return FactBaseControllerApiFp(this.configuration).getAnnualTimeSeries(factId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} factIds 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseControllerApi
     */
    public getAnnualTimeSeries1(factIds: Array<string>, options?: any) {
        return FactBaseControllerApiFp(this.configuration).getAnnualTimeSeries1(factIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} factId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactBaseControllerApi
     */
    public getFact(factId: string, options?: any) {
        return FactBaseControllerApiFp(this.configuration).getFact(factId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FactTimeSeriesControllerApi - axios parameter creator
 * @export
 */
export const FactTimeSeriesControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {Array<string>} conceptNames 
         * @param {string} [startDate] 
         * @param {string} [stopDate] 
         * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
         * @param {boolean} [prune] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeries: async (cik: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('getTimeSeries', 'cik', cik)
            // verify required parameter 'conceptNames' is not null or undefined
            assertParamExists('getTimeSeries', 'conceptNames', conceptNames)
            const localVarPath = `/api/fact-base/time-series`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (conceptNames) {
                localVarQueryParameter['conceptNames'] = conceptNames;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (stopDate !== undefined) {
                localVarQueryParameter['stopDate'] = (stopDate as any instanceof Date) ?
                    (stopDate as any).toISOString().substr(0,10) :
                    stopDate;
            }

            if (documentFiscalPeriodFocus !== undefined) {
                localVarQueryParameter['documentFiscalPeriodFocus'] = documentFiscalPeriodFocus;
            }

            if (prune !== undefined) {
                localVarQueryParameter['prune'] = prune;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} cik 
         * @param {string} factId 
         * @param {Array<string>} conceptNames 
         * @param {string} [startDate] 
         * @param {string} [stopDate] 
         * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
         * @param {boolean} [prune] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesForFact: async (cik: string, factId: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('getTimeSeriesForFact', 'cik', cik)
            // verify required parameter 'factId' is not null or undefined
            assertParamExists('getTimeSeriesForFact', 'factId', factId)
            // verify required parameter 'conceptNames' is not null or undefined
            assertParamExists('getTimeSeriesForFact', 'conceptNames', conceptNames)
            const localVarPath = `/api/fact-base/time-series/{factId}`
                .replace(`{${"factId"}}`, encodeURIComponent(String(factId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (conceptNames) {
                localVarQueryParameter['conceptNames'] = conceptNames;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (stopDate !== undefined) {
                localVarQueryParameter['stopDate'] = (stopDate as any instanceof Date) ?
                    (stopDate as any).toISOString().substr(0,10) :
                    stopDate;
            }

            if (documentFiscalPeriodFocus !== undefined) {
                localVarQueryParameter['documentFiscalPeriodFocus'] = documentFiscalPeriodFocus;
            }

            if (prune !== undefined) {
                localVarQueryParameter['prune'] = prune;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FactTimeSeriesControllerApi - functional programming interface
 * @export
 */
export const FactTimeSeriesControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FactTimeSeriesControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {Array<string>} conceptNames 
         * @param {string} [startDate] 
         * @param {string} [stopDate] 
         * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
         * @param {boolean} [prune] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeSeries(cik: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FactTimeSeries>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeSeries(cik, conceptNames, startDate, stopDate, documentFiscalPeriodFocus, prune, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} cik 
         * @param {string} factId 
         * @param {Array<string>} conceptNames 
         * @param {string} [startDate] 
         * @param {string} [stopDate] 
         * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
         * @param {boolean} [prune] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeSeriesForFact(cik: string, factId: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FactTimeSeries>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimeSeriesForFact(cik, factId, conceptNames, startDate, stopDate, documentFiscalPeriodFocus, prune, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FactTimeSeriesControllerApi - factory interface
 * @export
 */
export const FactTimeSeriesControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FactTimeSeriesControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {Array<string>} conceptNames 
         * @param {string} [startDate] 
         * @param {string} [stopDate] 
         * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
         * @param {boolean} [prune] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeries(cik: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options?: any): AxiosPromise<Array<FactTimeSeries>> {
            return localVarFp.getTimeSeries(cik, conceptNames, startDate, stopDate, documentFiscalPeriodFocus, prune, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} cik 
         * @param {string} factId 
         * @param {Array<string>} conceptNames 
         * @param {string} [startDate] 
         * @param {string} [stopDate] 
         * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
         * @param {boolean} [prune] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeSeriesForFact(cik: string, factId: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options?: any): AxiosPromise<Array<FactTimeSeries>> {
            return localVarFp.getTimeSeriesForFact(cik, factId, conceptNames, startDate, stopDate, documentFiscalPeriodFocus, prune, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FactTimeSeriesControllerApi - object-oriented interface
 * @export
 * @class FactTimeSeriesControllerApi
 * @extends {BaseAPI}
 */
export class FactTimeSeriesControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {Array<string>} conceptNames 
     * @param {string} [startDate] 
     * @param {string} [stopDate] 
     * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
     * @param {boolean} [prune] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactTimeSeriesControllerApi
     */
    public getTimeSeries(cik: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options?: any) {
        return FactTimeSeriesControllerApiFp(this.configuration).getTimeSeries(cik, conceptNames, startDate, stopDate, documentFiscalPeriodFocus, prune, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} cik 
     * @param {string} factId 
     * @param {Array<string>} conceptNames 
     * @param {string} [startDate] 
     * @param {string} [stopDate] 
     * @param {'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA'} [documentFiscalPeriodFocus] 
     * @param {boolean} [prune] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FactTimeSeriesControllerApi
     */
    public getTimeSeriesForFact(cik: string, factId: string, conceptNames: Array<string>, startDate?: string, stopDate?: string, documentFiscalPeriodFocus?: 'FY' | 'Q1' | 'Q2' | 'Q3' | 'Q4' | 'NA', prune?: boolean, options?: any) {
        return FactTimeSeriesControllerApiFp(this.configuration).getTimeSeriesForFact(cik, factId, conceptNames, startDate, stopDate, documentFiscalPeriodFocus, prune, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilingEntityManagerControllerApi - axios parameter creator
 * @export
 */
export const FilingEntityManagerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilingEntity: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('createFilingEntity', 'cik', cik)
            const localVarPath = `/public/filing-entity-manager/{cik}/create`
                .replace(`{${"cik"}}`, encodeURIComponent(String(cik)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FilingEntity} filingEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilingEntity: async (filingEntity: FilingEntity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'filingEntity' is not null or undefined
            assertParamExists('saveFilingEntity', 'filingEntity', filingEntity)
            const localVarPath = `/public/filing-entity-manager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(filingEntity, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilingEntityManagerControllerApi - functional programming interface
 * @export
 */
export const FilingEntityManagerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilingEntityManagerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFilingEntity(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFilingEntity(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FilingEntity} filingEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFilingEntity(filingEntity: FilingEntity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFilingEntity(filingEntity, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilingEntityManagerControllerApi - factory interface
 * @export
 */
export const FilingEntityManagerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilingEntityManagerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFilingEntity(cik: string, options?: any): AxiosPromise<FilingEntity> {
            return localVarFp.createFilingEntity(cik, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FilingEntity} filingEntity 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFilingEntity(filingEntity: FilingEntity, options?: any): AxiosPromise<void> {
            return localVarFp.saveFilingEntity(filingEntity, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilingEntityManagerControllerApi - object-oriented interface
 * @export
 * @class FilingEntityManagerControllerApi
 * @extends {BaseAPI}
 */
export class FilingEntityManagerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerControllerApi
     */
    public createFilingEntity(cik: string, options?: any) {
        return FilingEntityManagerControllerApiFp(this.configuration).createFilingEntity(cik, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FilingEntity} filingEntity 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerControllerApi
     */
    public saveFilingEntity(filingEntity: FilingEntity, options?: any) {
        return FilingEntityManagerControllerApiFp(this.configuration).saveFilingEntity(filingEntity, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FilingEntityManagerUnsecuredControllerApi - axios parameter creator
 * @export
 */
export const FilingEntityManagerUnsecuredControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilingEntity: async (cik: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('getFilingEntity', 'cik', cik)
            const localVarPath = `/public/filing-entity-manager/{cik}`
                .replace(`{${"cik"}}`, encodeURIComponent(String(cik)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FilingEntityManagerUnsecuredControllerApi - functional programming interface
 * @export
 */
export const FilingEntityManagerUnsecuredControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FilingEntityManagerUnsecuredControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFilingEntity(cik: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilingEntity>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFilingEntity(cik, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FilingEntityManagerUnsecuredControllerApi - factory interface
 * @export
 */
export const FilingEntityManagerUnsecuredControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FilingEntityManagerUnsecuredControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFilingEntity(cik: string, options?: any): AxiosPromise<FilingEntity> {
            return localVarFp.getFilingEntity(cik, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FilingEntityManagerUnsecuredControllerApi - object-oriented interface
 * @export
 * @class FilingEntityManagerUnsecuredControllerApi
 * @extends {BaseAPI}
 */
export class FilingEntityManagerUnsecuredControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilingEntityManagerUnsecuredControllerApi
     */
    public getFilingEntity(cik: string, options?: any) {
        return FilingEntityManagerUnsecuredControllerApiFp(this.configuration).getFilingEntity(cik, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IssuesControllerApi - axios parameter creator
 * @export
 */
export const IssuesControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssue: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteIssue', 'id', id)
            const localVarPath = `/api/issues/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIssues: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('findIssues', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateIssues: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('generateIssues', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/issues/generate-issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Issue>} issue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIssues: async (issue: Array<Issue>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'issue' is not null or undefined
            assertParamExists('saveIssues', 'issue', issue)
            const localVarPath = `/api/issues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(issue, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssuesControllerApi - functional programming interface
 * @export
 */
export const IssuesControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssuesControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteIssue(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteIssue(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIssues(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIssues(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateIssues(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateIssues(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<Issue>} issue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveIssues(issue: Array<Issue>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveIssues(issue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IssuesControllerApi - factory interface
 * @export
 */
export const IssuesControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssuesControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIssue(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteIssue(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIssues(stockAnalysisId: string, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.findIssues(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateIssues(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.generateIssues(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Issue>} issue 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveIssues(issue: Array<Issue>, options?: any): AxiosPromise<void> {
            return localVarFp.saveIssues(issue, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssuesControllerApi - object-oriented interface
 * @export
 * @class IssuesControllerApi
 * @extends {BaseAPI}
 */
export class IssuesControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesControllerApi
     */
    public deleteIssue(id: string, options?: any) {
        return IssuesControllerApiFp(this.configuration).deleteIssue(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesControllerApi
     */
    public findIssues(stockAnalysisId: string, options?: any) {
        return IssuesControllerApiFp(this.configuration).findIssues(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesControllerApi
     */
    public generateIssues(stockAnalysis2: StockAnalysis2, options?: any) {
        return IssuesControllerApiFp(this.configuration).generateIssues(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<Issue>} issue 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssuesControllerApi
     */
    public saveIssues(issue: Array<Issue>, options?: any) {
        return IssuesControllerApiFp(this.configuration).saveIssues(issue, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MarketingControllerApi - axios parameter creator
 * @export
 */
export const MarketingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {EarlyAccessRequest} earlyAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earlyAccessRequests: async (earlyAccessRequest: EarlyAccessRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'earlyAccessRequest' is not null or undefined
            assertParamExists('earlyAccessRequests', 'earlyAccessRequest', earlyAccessRequest)
            const localVarPath = `/public/marketing/early-access-requests`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(earlyAccessRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedback20210329: async (feedback: Feedback, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedback' is not null or undefined
            assertParamExists('feedback20210329', 'feedback', feedback)
            const localVarPath = `/public/marketing/2021-03-29/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedback, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StockAnalysisInterest} stockAnalysisInterest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisInterest: async (stockAnalysisInterest: StockAnalysisInterest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisInterest' is not null or undefined
            assertParamExists('stockAnalysisInterest', 'stockAnalysisInterest', stockAnalysisInterest)
            const localVarPath = `/public/marketing/stock-analysis-interest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysisInterest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisRequest: async (stockAnalysisRequest: Array<StockAnalysisRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisRequest' is not null or undefined
            assertParamExists('stockAnalysisRequest', 'stockAnalysisRequest', stockAnalysisRequest)
            const localVarPath = `/public/marketing/stock-analysis-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MarketingControllerApi - functional programming interface
 * @export
 */
export const MarketingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MarketingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {EarlyAccessRequest} earlyAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async earlyAccessRequests(earlyAccessRequest: EarlyAccessRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.earlyAccessRequests(earlyAccessRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedback20210329(feedback: Feedback, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedback20210329(feedback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StockAnalysisInterest} stockAnalysisInterest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockAnalysisInterest(stockAnalysisInterest: StockAnalysisInterest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockAnalysisInterest(stockAnalysisInterest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stockAnalysisRequest(stockAnalysisRequest: Array<StockAnalysisRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stockAnalysisRequest(stockAnalysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MarketingControllerApi - factory interface
 * @export
 */
export const MarketingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MarketingControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {EarlyAccessRequest} earlyAccessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        earlyAccessRequests(earlyAccessRequest: EarlyAccessRequest, options?: any): AxiosPromise<void> {
            return localVarFp.earlyAccessRequests(earlyAccessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Feedback} feedback 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedback20210329(feedback: Feedback, options?: any): AxiosPromise<void> {
            return localVarFp.feedback20210329(feedback, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StockAnalysisInterest} stockAnalysisInterest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisInterest(stockAnalysisInterest: StockAnalysisInterest, options?: any): AxiosPromise<void> {
            return localVarFp.stockAnalysisInterest(stockAnalysisInterest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stockAnalysisRequest(stockAnalysisRequest: Array<StockAnalysisRequest>, options?: any): AxiosPromise<void> {
            return localVarFp.stockAnalysisRequest(stockAnalysisRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MarketingControllerApi - object-oriented interface
 * @export
 * @class MarketingControllerApi
 * @extends {BaseAPI}
 */
export class MarketingControllerApi extends BaseAPI {
    /**
     * 
     * @param {EarlyAccessRequest} earlyAccessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public earlyAccessRequests(earlyAccessRequest: EarlyAccessRequest, options?: any) {
        return MarketingControllerApiFp(this.configuration).earlyAccessRequests(earlyAccessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Feedback} feedback 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public feedback20210329(feedback: Feedback, options?: any) {
        return MarketingControllerApiFp(this.configuration).feedback20210329(feedback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StockAnalysisInterest} stockAnalysisInterest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public stockAnalysisInterest(stockAnalysisInterest: StockAnalysisInterest, options?: any) {
        return MarketingControllerApiFp(this.configuration).stockAnalysisInterest(stockAnalysisInterest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<StockAnalysisRequest>} stockAnalysisRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketingControllerApi
     */
    public stockAnalysisRequest(stockAnalysisRequest: Array<StockAnalysisRequest>, options?: any) {
        return MarketingControllerApiFp(this.configuration).stockAnalysisRequest(stockAnalysisRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModelBuilderFactoryControllerApi - axios parameter creator
 * @export
 */
export const ModelBuilderFactoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestEffortModel: async (cik: string, adsh: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('bestEffortModel', 'cik', cik)
            // verify required parameter 'adsh' is not null or undefined
            assertParamExists('bestEffortModel', 'adsh', adsh)
            const localVarPath = `/api/sec/model-builder-factory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (adsh !== undefined) {
                localVarQueryParameter['adsh'] = adsh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModelBuilderFactoryControllerApi - functional programming interface
 * @export
 */
export const ModelBuilderFactoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModelBuilderFactoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bestEffortModel(cik: string, adsh: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Model>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bestEffortModel(cik, adsh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModelBuilderFactoryControllerApi - factory interface
 * @export
 */
export const ModelBuilderFactoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModelBuilderFactoryControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bestEffortModel(cik: string, adsh: string, options?: any): AxiosPromise<Model> {
            return localVarFp.bestEffortModel(cik, adsh, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModelBuilderFactoryControllerApi - object-oriented interface
 * @export
 * @class ModelBuilderFactoryControllerApi
 * @extends {BaseAPI}
 */
export class ModelBuilderFactoryControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {string} adsh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModelBuilderFactoryControllerApi
     */
    public bestEffortModel(cik: string, adsh: string, options?: any) {
        return ModelBuilderFactoryControllerApiFp(this.configuration).bestEffortModel(cik, adsh, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MxParserControllerApi - axios parameter creator
 * @export
 */
export const MxParserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate: async (mxParserEvaluateRequest: MxParserEvaluateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mxParserEvaluateRequest' is not null or undefined
            assertParamExists('evaluate', 'mxParserEvaluateRequest', mxParserEvaluateRequest)
            const localVarPath = `/api/mxparser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mxParserEvaluateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MxParserControllerApi - functional programming interface
 * @export
 */
export const MxParserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MxParserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluate(mxParserEvaluateRequest: MxParserEvaluateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MxParserEvaluateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluate(mxParserEvaluateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MxParserControllerApi - factory interface
 * @export
 */
export const MxParserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MxParserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluate(mxParserEvaluateRequest: MxParserEvaluateRequest, options?: any): AxiosPromise<MxParserEvaluateResponse> {
            return localVarFp.evaluate(mxParserEvaluateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MxParserControllerApi - object-oriented interface
 * @export
 * @class MxParserControllerApi
 * @extends {BaseAPI}
 */
export class MxParserControllerApi extends BaseAPI {
    /**
     * 
     * @param {MxParserEvaluateRequest} mxParserEvaluateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MxParserControllerApi
     */
    public evaluate(mxParserEvaluateRequest: MxParserEvaluateRequest, options?: any) {
        return MxParserControllerApiFp(this.configuration).evaluate(mxParserEvaluateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrphanedItemsFinderControllerApi - axios parameter creator
 * @export
 */
export const OrphanedItemsFinderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orphanedItems: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('orphanedItems', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/orphaned-items-finder`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrphanedItemsFinderControllerApi - functional programming interface
 * @export
 */
export const OrphanedItemsFinderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrphanedItemsFinderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orphanedItems(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Item>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orphanedItems(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrphanedItemsFinderControllerApi - factory interface
 * @export
 */
export const OrphanedItemsFinderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrphanedItemsFinderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orphanedItems(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<Array<Item>> {
            return localVarFp.orphanedItems(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrphanedItemsFinderControllerApi - object-oriented interface
 * @export
 * @class OrphanedItemsFinderControllerApi
 * @extends {BaseAPI}
 */
export class OrphanedItemsFinderControllerApi extends BaseAPI {
    /**
     * 
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrphanedItemsFinderControllerApi
     */
    public orphanedItems(stockAnalysis2: StockAnalysis2, options?: any) {
        return OrphanedItemsFinderControllerApiFp(this.configuration).orphanedItems(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessSecFilingRequestPublisherControllerApi - axios parameter creator
 * @export
 */
export const ProcessSecFilingRequestPublisherControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishRequest: async (cik: string, adsh: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cik' is not null or undefined
            assertParamExists('publishRequest', 'cik', cik)
            // verify required parameter 'adsh' is not null or undefined
            assertParamExists('publishRequest', 'adsh', adsh)
            const localVarPath = `/public/process-secfiling-request-publisher/publish-request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (adsh !== undefined) {
                localVarQueryParameter['adsh'] = adsh;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessSecFilingRequestPublisherControllerApi - functional programming interface
 * @export
 */
export const ProcessSecFilingRequestPublisherControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessSecFilingRequestPublisherControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishRequest(cik: string, adsh: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishRequest(cik, adsh, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessSecFilingRequestPublisherControllerApi - factory interface
 * @export
 */
export const ProcessSecFilingRequestPublisherControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessSecFilingRequestPublisherControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} cik 
         * @param {string} adsh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishRequest(cik: string, adsh: string, options?: any): AxiosPromise<void> {
            return localVarFp.publishRequest(cik, adsh, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessSecFilingRequestPublisherControllerApi - object-oriented interface
 * @export
 * @class ProcessSecFilingRequestPublisherControllerApi
 * @extends {BaseAPI}
 */
export class ProcessSecFilingRequestPublisherControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} cik 
     * @param {string} adsh 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessSecFilingRequestPublisherControllerApi
     */
    public publishRequest(cik: string, adsh: string, options?: any) {
        return ProcessSecFilingRequestPublisherControllerApiFp(this.configuration).publishRequest(cik, adsh, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PublishedStockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const PublishedStockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses: async (userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublishedStockAnalysis', 'id', id)
            const localVarPath = `/public/published-stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        top4StockAnalyses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses/top4`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - functional programming interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublishedStockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async top4StockAnalyses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.top4StockAnalyses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - factory interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublishedStockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getPublishedStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        top4StockAnalyses(options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.top4StockAnalyses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublishedStockAnalysisControllerApi - object-oriented interface
 * @export
 * @class PublishedStockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class PublishedStockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public getPublishedStockAnalysis(id: string, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).getPublishedStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public top4StockAnalyses(options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).top4StockAnalyses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RevenueModelerControllerApi - axios parameter creator
 * @export
 */
export const RevenueModelerControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRevenueModel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRevenueModel', 'id', id)
            const localVarPath = `/public/revenue-modeler/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueModel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRevenueModel', 'id', id)
            const localVarPath = `/public/revenue-modeler/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ModelRevenueRequest} modelRevenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelRevenue: async (modelRevenueRequest: ModelRevenueRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'modelRevenueRequest' is not null or undefined
            assertParamExists('modelRevenue', 'modelRevenueRequest', modelRevenueRequest)
            const localVarPath = `/public/revenue-modeler/model-revenue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modelRevenueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RevenueModel} revenueModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRevenueModel: async (revenueModel: RevenueModel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'revenueModel' is not null or undefined
            assertParamExists('saveRevenueModel', 'revenueModel', revenueModel)
            const localVarPath = `/public/revenue-modeler`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revenueModel, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RevenueModelerControllerApi - functional programming interface
 * @export
 */
export const RevenueModelerControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RevenueModelerControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRevenueModel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRevenueModel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRevenueModel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RevenueModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRevenueModel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ModelRevenueRequest} modelRevenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelRevenue(modelRevenueRequest: ModelRevenueRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualProjections>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelRevenue(modelRevenueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RevenueModel} revenueModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRevenueModel(revenueModel: RevenueModel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRevenueModel(revenueModel, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RevenueModelerControllerApi - factory interface
 * @export
 */
export const RevenueModelerControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RevenueModelerControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRevenueModel(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRevenueModel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRevenueModel(id: string, options?: any): AxiosPromise<RevenueModel> {
            return localVarFp.getRevenueModel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ModelRevenueRequest} modelRevenueRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelRevenue(modelRevenueRequest: ModelRevenueRequest, options?: any): AxiosPromise<ManualProjections> {
            return localVarFp.modelRevenue(modelRevenueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RevenueModel} revenueModel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRevenueModel(revenueModel: RevenueModel, options?: any): AxiosPromise<void> {
            return localVarFp.saveRevenueModel(revenueModel, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RevenueModelerControllerApi - object-oriented interface
 * @export
 * @class RevenueModelerControllerApi
 * @extends {BaseAPI}
 */
export class RevenueModelerControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevenueModelerControllerApi
     */
    public deleteRevenueModel(id: string, options?: any) {
        return RevenueModelerControllerApiFp(this.configuration).deleteRevenueModel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevenueModelerControllerApi
     */
    public getRevenueModel(id: string, options?: any) {
        return RevenueModelerControllerApiFp(this.configuration).getRevenueModel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ModelRevenueRequest} modelRevenueRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevenueModelerControllerApi
     */
    public modelRevenue(modelRevenueRequest: ModelRevenueRequest, options?: any) {
        return RevenueModelerControllerApiFp(this.configuration).modelRevenue(modelRevenueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RevenueModel} revenueModel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RevenueModelerControllerApi
     */
    public saveRevenueModel(revenueModel: RevenueModel, options?: any) {
        return RevenueModelerControllerApiFp(this.configuration).saveRevenueModel(revenueModel, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis: async (evaluateModelRequest: EvaluateModelRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'evaluateModelRequest' is not null or undefined
            assertParamExists('evaluateStockAnalysis', 'evaluateModelRequest', evaluateModelRequest)
            const localVarPath = `/api/stock-analyzer/stock-analyses/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(evaluateModelRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses: async (published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @summary Refresh a stock analysis by rerunning the model
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStockAnalysis: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('refreshStockAnalysis', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/stock-analyzer/stock-analyses/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStockAnalysis: async (stockAnalysis2: StockAnalysis2, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysis2' is not null or undefined
            assertParamExists('saveStockAnalysis', 'stockAnalysis2', stockAnalysis2)
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stockAnalysis2, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/unpublish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EvaluateModelResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateStockAnalysis(evaluateModelRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @summary Refresh a stock analysis by rerunning the model
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshStockAnalysis(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveStockAnalysis(stockAnalysis2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisControllerApi - factory interface
 * @export
 */
export const StockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
         * @param {EvaluateModelRequest} evaluateModelRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any): AxiosPromise<EvaluateModelResponse> {
            return localVarFp.evaluateStockAnalysis(evaluateModelRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.publish(id, options).then((request) => request(axios, basePath));
        },
        /**
         *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
         * @summary Refresh a stock analysis by rerunning the model
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.refreshStockAnalysis(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StockAnalysis2} stockAnalysis2 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any): AxiosPromise<void> {
            return localVarFp.saveStockAnalysis(stockAnalysis2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.unpublish(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public deleteStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).deleteStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          This API evaluates a model you\'ve assembled and return a stock analysis object                   The passed in Model represents high level relationship between the various financial statement items of underlying a stock          Calling this method evaluates those relationships and turn them into real numbers                  This API does not persist (save) the stock analysis. Please call the stock analysis service API to save the analysis                  This is a stateless calculator         
     * @param {EvaluateModelRequest} evaluateModelRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public evaluateStockAnalysis(evaluateModelRequest: EvaluateModelRequest, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).evaluateStockAnalysis(evaluateModelRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [published] 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public getStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).getStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public publish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).publish(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *          This API refreshes an existing stock analysis and re-evaluate         the model attached to it to produce renewed outputs. Call this API          when you are in possession of a previously run stock analysis                  The returned refreshed stock analysis preserve all the metadata, model overrides         of the original analysis                  This API does not persist (save) the new analysis. This API is a stateless calculator         
     * @summary Refresh a stock analysis by rerunning the model
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public refreshStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).refreshStockAnalysis(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StockAnalysis2} stockAnalysis2 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public saveStockAnalysis(stockAnalysis2: StockAnalysis2, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).saveStockAnalysis(stockAnalysis2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public unpublish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).unpublish(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisCronJobsControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisCronJobsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analysis-cron-jobs/update-prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisCronJobsControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisCronJobsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisCronJobsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisCronJobsControllerApi - factory interface
 * @export
 */
export const StockAnalysisCronJobsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisCronJobsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrices(options?: any): AxiosPromise<void> {
            return localVarFp.updatePrices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisCronJobsControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisCronJobsControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisCronJobsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisCronJobsControllerApi
     */
    public updatePrices(options?: any) {
        return StockAnalysisCronJobsControllerApiFp(this.configuration).updatePrices(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisExcelDownloaderControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisExcelDownloaderControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('download', 'id', id)
            const localVarPath = `/public/stock-analyses/{id}/excel-download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisExcelDownloaderControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisExcelDownloaderControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisExcelDownloaderControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisExcelDownloaderControllerApi - factory interface
 * @export
 */
export const StockAnalysisExcelDownloaderControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisExcelDownloaderControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.download(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisExcelDownloaderControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisExcelDownloaderControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisExcelDownloaderControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisExcelDownloaderControllerApi
     */
    public download(id: string, options?: any) {
        return StockAnalysisExcelDownloaderControllerApiFp(this.configuration).download(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TagControllerApi - axios parameter creator
 * @export
 */
export const TagControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTag', 'id', id)
            const localVarPath = `/api/tags/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTag: async (term: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('findTag', 'term', term)
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag: async (tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('saveTag', 'tag', tag)
            const localVarPath = `/api/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagControllerApi - functional programming interface
 * @export
 */
export const TagControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTag(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTag(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTag(term: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTag(term, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTag(tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTag(tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TagControllerApi - factory interface
 * @export
 */
export const TagControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTag(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} term 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTag(term: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.findTag(term, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTag(tag: Tag, options?: any): AxiosPromise<void> {
            return localVarFp.saveTag(tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagControllerApi - object-oriented interface
 * @export
 * @class TagControllerApi
 * @extends {BaseAPI}
 */
export class TagControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public deleteTag(id: string, options?: any) {
        return TagControllerApiFp(this.configuration).deleteTag(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} term 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public findTag(term: string, options?: any) {
        return TagControllerApiFp(this.configuration).findTag(term, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagControllerApi
     */
    public saveTag(tag: Tag, options?: any) {
        return TagControllerApiFp(this.configuration).saveTag(tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WatchListsControllerApi - axios parameter creator
 * @export
 */
export const WatchListsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatch: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('unwatch', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watch: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('watch', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchListsControllerApi - functional programming interface
 * @export
 */
export const WatchListsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchListsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unwatch(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unwatch(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watch(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watch(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WatchListsControllerApi - factory interface
 * @export
 */
export const WatchListsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchListsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchList(options?: any): AxiosPromise<WatchList> {
            return localVarFp.getWatchList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatch(stockAnalysisId: string, options?: any): AxiosPromise<WatchList> {
            return localVarFp.unwatch(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watch(stockAnalysisId: string, options?: any): AxiosPromise<WatchList> {
            return localVarFp.watch(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchListsControllerApi - object-oriented interface
 * @export
 * @class WatchListsControllerApi
 * @extends {BaseAPI}
 */
export class WatchListsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public getWatchList(options?: any) {
        return WatchListsControllerApiFp(this.configuration).getWatchList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public unwatch(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).unwatch(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public watch(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).watch(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ZacksEstimatesControllerApi - axios parameter creator
 * @export
 */
export const ZacksEstimatesControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} ticker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZacksSaleEstimates: async (ticker: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('getZacksSaleEstimates', 'ticker', ticker)
            const localVarPath = `/api/zacks-estimates/{ticker}`
                .replace(`{${"ticker"}}`, encodeURIComponent(String(ticker)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ticker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revenueProjections: async (ticker: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ticker' is not null or undefined
            assertParamExists('revenueProjections', 'ticker', ticker)
            const localVarPath = `/api/zacks-estimates/revenue-projections`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ZacksEstimatesControllerApi - functional programming interface
 * @export
 */
export const ZacksEstimatesControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ZacksEstimatesControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} ticker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZacksSaleEstimates(ticker: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZacksSalesEstimates>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getZacksSaleEstimates(ticker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} ticker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revenueProjections(ticker: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ManualProjections>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revenueProjections(ticker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ZacksEstimatesControllerApi - factory interface
 * @export
 */
export const ZacksEstimatesControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ZacksEstimatesControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} ticker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZacksSaleEstimates(ticker: string, options?: any): AxiosPromise<Array<ZacksSalesEstimates>> {
            return localVarFp.getZacksSaleEstimates(ticker, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ticker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revenueProjections(ticker: string, options?: any): AxiosPromise<ManualProjections> {
            return localVarFp.revenueProjections(ticker, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ZacksEstimatesControllerApi - object-oriented interface
 * @export
 * @class ZacksEstimatesControllerApi
 * @extends {BaseAPI}
 */
export class ZacksEstimatesControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} ticker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZacksEstimatesControllerApi
     */
    public getZacksSaleEstimates(ticker: string, options?: any) {
        return ZacksEstimatesControllerApiFp(this.configuration).getZacksSaleEstimates(ticker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ticker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ZacksEstimatesControllerApi
     */
    public revenueProjections(ticker: string, options?: any) {
        return ZacksEstimatesControllerApiFp(this.configuration).revenueProjections(ticker, options).then((request) => request(this.axios, this.basePath));
    }
}


