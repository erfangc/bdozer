/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    sheet: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    sheetName: string;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    row: number;
    /**
     * 
     * @type {number}
     * @memberof Address
     */
    column: number;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    columnLetter: string;
}
/**
 * 
 * @export
 * @interface Cell
 */
export interface Cell {
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    period: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    name: string;
    /**
     * 
     * @type {Item}
     * @memberof Cell
     */
    item: Item;
    /**
     * 
     * @type {number}
     * @memberof Cell
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    formula?: string;
    /**
     * 
     * @type {string}
     * @memberof Cell
     */
    excelFormula?: string;
    /**
     * 
     * @type {Address}
     * @memberof Cell
     */
    address?: Address;
    /**
     * 
     * @type {Array<string>}
     * @memberof Cell
     */
    dependentCellNames: Array<string>;
}
/**
 * 
 * @export
 * @interface Commentary
 */
export interface Commentary {
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    commentary?: string;
    /**
     * 
     * @type {string}
     * @memberof Commentary
     */
    generatorClass?: string;
}
/**
 * 
 * @export
 * @interface Component
 */
export interface Component {
    /**
     * 
     * @type {number}
     * @memberof Component
     */
    weight: number;
    /**
     * 
     * @type {string}
     * @memberof Component
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface CompoundedGrowth
 */
export interface CompoundedGrowth {
    /**
     * 
     * @type {number}
     * @memberof CompoundedGrowth
     */
    growthRate: number;
}
/**
 * 
 * @export
 * @interface DerivedStockAnalytics
 */
export interface DerivedStockAnalytics {
    /**
     * 
     * @type {{ [key: string]: Waterfall; }}
     * @memberof DerivedStockAnalytics
     */
    businessWaterfall: { [key: string]: Waterfall; };
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    marketCap?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    employees?: number;
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    shareOutstanding: Item;
    /**
     * 
     * @type {Item}
     * @memberof DerivedStockAnalytics
     */
    profitPerShare: Item;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    targetPrice: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    finalPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    discountRate?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    revenueCAGR?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    currentPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof DerivedStockAnalytics
     */
    irr?: number;
}
/**
 * 
 * @export
 * @interface FindStockAnalysisResponse
 */
export interface FindStockAnalysisResponse {
    /**
     * 
     * @type {Array<StockAnalysisProjection>}
     * @memberof FindStockAnalysisResponse
     */
    stockAnalyses: Array<StockAnalysisProjection>;
}
/**
 * 
 * @export
 * @interface FixedCost
 */
export interface FixedCost {
    /**
     * 
     * @type {number}
     * @memberof FixedCost
     */
    cost: number;
}
/**
 * 
 * @export
 * @interface GetWatchedStockAnalysesResponse
 */
export interface GetWatchedStockAnalysesResponse {
    /**
     * 
     * @type {WatchList}
     * @memberof GetWatchedStockAnalysesResponse
     */
    watchList: WatchList;
    /**
     * 
     * @type {Array<StockAnalysis2>}
     * @memberof GetWatchedStockAnalysesResponse
     */
    stockAnalyses: Array<StockAnalysis2>;
}
/**
 * 
 * @export
 * @interface HistoricalValue
 */
export interface HistoricalValue {
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    factId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof HistoricalValue
     */
    factIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    conceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentFiscalPeriodFocus?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    documentFiscalYearFocus?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    documentPeriodEndDate?: string;
    /**
     * 
     * @type {number}
     * @memberof HistoricalValue
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    startDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    endDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoricalValue
     */
    instant?: string;
}
/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    type: ItemTypeEnum;
    /**
     * 
     * @type {HistoricalValue}
     * @memberof Item
     */
    historicalValue?: HistoricalValue;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    formula: string;
    /**
     * 
     * @type {SumOfOtherItems}
     * @memberof Item
     */
    sumOfOtherItems?: SumOfOtherItems;
    /**
     * 
     * @type {ProductOfOtherItems}
     * @memberof Item
     */
    productOfOtherItems?: ProductOfOtherItems;
    /**
     * 
     * @type {ManualProjections}
     * @memberof Item
     */
    manualProjections?: ManualProjections;
    /**
     * 
     * @type {PercentOfRevenue}
     * @memberof Item
     */
    percentOfRevenue?: PercentOfRevenue;
    /**
     * 
     * @type {PercentOfAnotherItem}
     * @memberof Item
     */
    percentOfAnotherItem?: PercentOfAnotherItem;
    /**
     * 
     * @type {CompoundedGrowth}
     * @memberof Item
     */
    compoundedGrowth?: CompoundedGrowth;
    /**
     * 
     * @type {FixedCost}
     * @memberof Item
     */
    fixedCost?: FixedCost;
    /**
     * 
     * @type {Commentary}
     * @memberof Item
     */
    commentaries?: Commentary;
}

/**
    * @export
    * @enum {string}
    */
export enum ItemTypeEnum {
    CompoundedGrowth = 'CompoundedGrowth',
    SumOfOtherItems = 'SumOfOtherItems',
    ProductOfOtherItems = 'ProductOfOtherItems',
    Custom = 'Custom',
    Discrete = 'Discrete',
    ManualProjections = 'ManualProjections',
    PercentOfRevenue = 'PercentOfRevenue',
    PercentOfAnotherItem = 'PercentOfAnotherItem',
    FixedCost = 'FixedCost'
}

/**
 * 
 * @export
 * @interface ManualProjection
 */
export interface ManualProjection {
    /**
     * 
     * @type {number}
     * @memberof ManualProjection
     */
    fiscalYear: number;
    /**
     * 
     * @type {number}
     * @memberof ManualProjection
     */
    value: number;
}
/**
 * 
 * @export
 * @interface ManualProjections
 */
export interface ManualProjections {
    /**
     * 
     * @type {Array<ManualProjection>}
     * @memberof ManualProjections
     */
    manualProjections: Array<ManualProjection>;
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    ticker?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    adsh?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    mostRecentReportDate?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    itemOverrides: Array<Item>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Model
     */
    suppressedItems: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    totalRevenueConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    epsConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    netIncomeConceptName?: string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    sharesOutstandingConceptName?: string;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    incomeStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    balanceSheetItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    cashFlowStatementItems: Array<Item>;
    /**
     * 
     * @type {Array<Item>}
     * @memberof Model
     */
    otherItems: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    beta: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    riskFreeRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    equityRiskPremium: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    terminalGrowthRate: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    periods: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelColumnOffset: number;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    excelRowOffset: number;
}
/**
 * 
 * @export
 * @interface PercentOfAnotherItem
 */
export interface PercentOfAnotherItem {
    /**
     * 
     * @type {string}
     * @memberof PercentOfAnotherItem
     */
    itemName: string;
    /**
     * 
     * @type {number}
     * @memberof PercentOfAnotherItem
     */
    percent: number;
}
/**
 * 
 * @export
 * @interface PercentOfRevenue
 */
export interface PercentOfRevenue {
    /**
     * 
     * @type {number}
     * @memberof PercentOfRevenue
     */
    percentOfRevenue: number;
}
/**
 * 
 * @export
 * @interface ProductComponent
 */
export interface ProductComponent {
    /**
     * 
     * @type {string}
     * @memberof ProductComponent
     */
    itemName: string;
}
/**
 * 
 * @export
 * @interface ProductOfOtherItems
 */
export interface ProductOfOtherItems {
    /**
     * 
     * @type {Array<ProductComponent>}
     * @memberof ProductOfOtherItems
     */
    components: Array<ProductComponent>;
}
/**
 * 
 * @export
 * @interface StockAnalysis2
 */
export interface StockAnalysis2 {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    ticker?: string;
    /**
     * 
     * @type {Model}
     * @memberof StockAnalysis2
     */
    model: Model;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof StockAnalysis2
     */
    cells: Array<Cell>;
    /**
     * 
     * @type {DerivedStockAnalytics}
     * @memberof StockAnalysis2
     */
    derivedStockAnalytics?: DerivedStockAnalytics;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    industry?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    sector?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    url?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysis2
     */
    similar?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    ceo?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    country?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    userId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysis2
     */
    tags: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysis2
     */
    published: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysis2
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface StockAnalysisProjection
 */
export interface StockAnalysisProjection {
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    get_id: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    cik?: string;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    ticker?: string;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    currentPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    targetPrice?: number;
    /**
     * 
     * @type {number}
     * @memberof StockAnalysisProjection
     */
    finalPrice?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StockAnalysisProjection
     */
    published?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StockAnalysisProjection
     */
    lastUpdated?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StockAnalysisProjection
     */
    tags: Array<string>;
}
/**
 * 
 * @export
 * @interface SumOfOtherItems
 */
export interface SumOfOtherItems {
    /**
     * 
     * @type {Array<Component>}
     * @memberof SumOfOtherItems
     */
    components: Array<Component>;
}
/**
 * 
 * @export
 * @interface WatchList
 */
export interface WatchList {
    /**
     * 
     * @type {string}
     * @memberof WatchList
     */
    get_id: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WatchList
     */
    stockAnalysisIds: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof WatchList
     */
    lastUpdated: string;
}
/**
 * 
 * @export
 * @interface Waterfall
 */
export interface Waterfall {
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    revenue: Cell;
    /**
     * 
     * @type {Array<Cell>}
     * @memberof Waterfall
     */
    expenses: Array<Cell>;
    /**
     * 
     * @type {Cell}
     * @memberof Waterfall
     */
    profit: Cell;
}

/**
 * PublishedStockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const PublishedStockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('download', 'id', id)
            const localVarPath = `/public/published-stock-analyses/{id}/excel-download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {'ascending' | 'descending'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses: async (userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublishedStockAnalysis', 'id', id)
            const localVarPath = `/public/published-stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        top4StockAnalyses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/public/published-stock-analyses/top4`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - functional programming interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublishedStockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {'ascending' | 'descending'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublishedStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublishedStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async top4StockAnalyses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.top4StockAnalyses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PublishedStockAnalysisControllerApi - factory interface
 * @export
 */
export const PublishedStockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublishedStockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.download(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {'ascending' | 'descending'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublishedStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getPublishedStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        top4StockAnalyses(options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.top4StockAnalyses(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublishedStockAnalysisControllerApi - object-oriented interface
 * @export
 * @class PublishedStockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class PublishedStockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public download(id: string, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).download(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {Array<string>} [tags] 
     * @param {'ascending' | 'descending'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public findPublishedStockAnalyses(userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).findPublishedStockAnalyses(userId, cik, ticker, skip, limit, term, tags, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public getPublishedStockAnalysis(id: string, options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).getPublishedStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublishedStockAnalysisControllerApi
     */
    public top4StockAnalyses(options?: any) {
        return PublishedStockAnalysisControllerApiFp(this.configuration).top4StockAnalyses(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Model} model 
         * @param {string} [saveAs] 
         * @param {boolean} [published] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis: async (model: Model, saveAs?: string, published?: boolean, tags?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'model' is not null or undefined
            assertParamExists('evaluateStockAnalysis', 'model', model)
            const localVarPath = `/api/stock-analyzer/stock-analyses/evaluate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (saveAs !== undefined) {
                localVarQueryParameter['saveAs'] = saveAs;
            }

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(model, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {'ascending' | 'descending'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses: async (published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analyzer/stock-analyses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (published !== undefined) {
                localVarQueryParameter['published'] = published;
            }

            if (userId !== undefined) {
                localVarQueryParameter['userId'] = userId;
            }

            if (cik !== undefined) {
                localVarQueryParameter['cik'] = cik;
            }

            if (ticker !== undefined) {
                localVarQueryParameter['ticker'] = ticker;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStockAnalysis', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('publish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/publish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unpublish', 'id', id)
            const localVarPath = `/api/stock-analyzer/stock-analyses/{id}/unpublish`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Model} model 
         * @param {string} [saveAs] 
         * @param {boolean} [published] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async evaluateStockAnalysis(model: Model, saveAs?: string, published?: boolean, tags?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.evaluateStockAnalysis(model, saveAs, published, tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {'ascending' | 'descending'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FindStockAnalysisResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, sort, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStockAnalysis(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStockAnalysis(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpublish(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StockAnalysis2>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpublish(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisControllerApi - factory interface
 * @export
 */
export const StockAnalysisControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteStockAnalysis(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Model} model 
         * @param {string} [saveAs] 
         * @param {boolean} [published] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateStockAnalysis(model: Model, saveAs?: string, published?: boolean, tags?: Array<string>, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.evaluateStockAnalysis(model, saveAs, published, tags, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [published] 
         * @param {string} [userId] 
         * @param {string} [cik] 
         * @param {string} [ticker] 
         * @param {number} [skip] 
         * @param {number} [limit] 
         * @param {string} [term] 
         * @param {Array<string>} [tags] 
         * @param {'ascending' | 'descending'} [sort] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options?: any): AxiosPromise<FindStockAnalysisResponse> {
            return localVarFp.findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStockAnalysis(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.getStockAnalysis(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.publish(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpublish(id: string, options?: any): AxiosPromise<StockAnalysis2> {
            return localVarFp.unpublish(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public deleteStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).deleteStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Model} model 
     * @param {string} [saveAs] 
     * @param {boolean} [published] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public evaluateStockAnalysis(model: Model, saveAs?: string, published?: boolean, tags?: Array<string>, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).evaluateStockAnalysis(model, saveAs, published, tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {boolean} [published] 
     * @param {string} [userId] 
     * @param {string} [cik] 
     * @param {string} [ticker] 
     * @param {number} [skip] 
     * @param {number} [limit] 
     * @param {string} [term] 
     * @param {Array<string>} [tags] 
     * @param {'ascending' | 'descending'} [sort] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public findStockAnalyses(published?: boolean, userId?: string, cik?: string, ticker?: string, skip?: number, limit?: number, term?: string, tags?: Array<string>, sort?: 'ascending' | 'descending', options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).findStockAnalyses(published, userId, cik, ticker, skip, limit, term, tags, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public getStockAnalysis(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).getStockAnalysis(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public publish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).publish(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisControllerApi
     */
    public unpublish(id: string, options?: any) {
        return StockAnalysisControllerApiFp(this.configuration).unpublish(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StockAnalysisCronJobsControllerApi - axios parameter creator
 * @export
 */
export const StockAnalysisCronJobsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrices: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/stock-analysis-cron-jobs/update-prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StockAnalysisCronJobsControllerApi - functional programming interface
 * @export
 */
export const StockAnalysisCronJobsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StockAnalysisCronJobsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePrices(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePrices(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StockAnalysisCronJobsControllerApi - factory interface
 * @export
 */
export const StockAnalysisCronJobsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StockAnalysisCronJobsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePrices(options?: any): AxiosPromise<void> {
            return localVarFp.updatePrices(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StockAnalysisCronJobsControllerApi - object-oriented interface
 * @export
 * @class StockAnalysisCronJobsControllerApi
 * @extends {BaseAPI}
 */
export class StockAnalysisCronJobsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StockAnalysisCronJobsControllerApi
     */
    public updatePrices(options?: any) {
        return StockAnalysisCronJobsControllerApiFp(this.configuration).updatePrices(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WatchListsControllerApi - axios parameter creator
 * @export
 */
export const WatchListsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedStockAnalyses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWatching: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('isWatching', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists/{stockAnalysisId}`
                .replace(`{${"stockAnalysisId"}}`, encodeURIComponent(String(stockAnalysisId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatch: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('unwatch', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watch: async (stockAnalysisId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stockAnalysisId' is not null or undefined
            assertParamExists('watch', 'stockAnalysisId', stockAnalysisId)
            const localVarPath = `/api/watch-lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (stockAnalysisId !== undefined) {
                localVarQueryParameter['stockAnalysisId'] = stockAnalysisId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WatchListsControllerApi - functional programming interface
 * @export
 */
export const WatchListsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WatchListsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWatchedStockAnalyses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWatchedStockAnalysesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWatchedStockAnalyses(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isWatching(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isWatching(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unwatch(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unwatch(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async watch(stockAnalysisId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.watch(stockAnalysisId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WatchListsControllerApi - factory interface
 * @export
 */
export const WatchListsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WatchListsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWatchedStockAnalyses(options?: any): AxiosPromise<GetWatchedStockAnalysesResponse> {
            return localVarFp.getWatchedStockAnalyses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isWatching(stockAnalysisId: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.isWatching(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unwatch(stockAnalysisId: string, options?: any): AxiosPromise<WatchList> {
            return localVarFp.unwatch(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} stockAnalysisId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        watch(stockAnalysisId: string, options?: any): AxiosPromise<WatchList> {
            return localVarFp.watch(stockAnalysisId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WatchListsControllerApi - object-oriented interface
 * @export
 * @class WatchListsControllerApi
 * @extends {BaseAPI}
 */
export class WatchListsControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public getWatchedStockAnalyses(options?: any) {
        return WatchListsControllerApiFp(this.configuration).getWatchedStockAnalyses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public isWatching(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).isWatching(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public unwatch(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).unwatch(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} stockAnalysisId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WatchListsControllerApi
     */
    public watch(stockAnalysisId: string, options?: any) {
        return WatchListsControllerApiFp(this.configuration).watch(stockAnalysisId, options).then((request) => request(this.axios, this.basePath));
    }
}


